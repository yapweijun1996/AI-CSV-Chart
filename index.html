<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CSV â†’ Aggregates + Cards + Data Table (Auto + Manual + More Charts, Improved)</title>

<!-- Chart.js v4 -->
<script src="./chart.umd.min.js"></script>
<!-- PapaParse -->
<script src="./papaparse.min.js"></script>
<script src="./marked.min.js"></script>


<link rel="stylesheet" href="ai_chart_style.css">
</head>
<body>
<nav id="sidebar" class="sidebar" aria-label="History sidebar">
  <div class="sidebar-header">
    <h3 class="sidebar-title">History</h3>
    <button id="aiSettingsBtn" title="AI Settings" class="tooltip" data-tooltip="AI Settings" aria-label="AI Settings">ğŸ¤–</button>
    <button id="manageHistoryBtn" title="Manage history" class="tooltip" data-tooltip="Manage history" aria-label="Manage history">âš™ï¸</button>
    <button id="sidebar-toggle" title="Toggle sidebar" aria-controls="sidebar" aria-expanded="true">â˜°</button>
  </div>
  <div class="sidebar-search">
    <input type="text" id="history-search" placeholder="Search reports..." />
  </div>
  <ul id="history-list" role="listbox" aria-label="Saved reports"></ul>
</nav>
<main id="main-content" class="main-content">
<div class="wrap">
  <div class="section" data-section-id="csv-input">
    <div class="section-header">
      <h2>CSV â†’ Aggregates (Card UI) + Raw Data Table</h2>
    </div>
    <div class="section-content" id="section-content-csv-input">
      <div class="bar">
        <input id="file" type="file" accept=".csv,.txt" style="display:none;" />
        <button id="fileSelectBtn">Select CSV File</button>
        <button id="loadBtn" style="display:none;">Load CSV</button>
        <button id="updateReportBtn" disabled>Update Report</button>
        <button id="saveAsNewBtn" disabled>Save as New</button>
        <span id="meta" class="muted"></span>
      </div>
      <div class="bar" style="margin-top:8px">
        <label>Delimiter:
          <span class="tooltip tooltip-wide" data-tooltip="Character that separates values in your CSV. Auto-detection usually works best. Override if parsing looks incorrect."></span>
          <select id="delimiter">
            <option value="auto">Auto</option>
            <option value=",">Comma (,)</option>
            <option value=";">Semicolon (;)</option>
            <option value="\t">Tab (\t)</option>
            <option value="|">Pipe (|)</option>
          </select>
        </label>
        <label><input id="hasHeader" type="checkbox" checked /> First row has headers
          <span class="tooltip tooltip-wide" data-tooltip="Check if your CSV's first row contains column names instead of data. Usually enabled for standard CSV files."></span>
        </label>
        <label>Date format:
          <span class="tooltip tooltip-wide" data-tooltip="Auto tries to detect day/month order. Override if chart sorting or recognition looks wrong. Default day-first (dd/mm/yyyy)."></span>
          <select id="dateFormat">
            <option value="auto">Auto (default: dd/mm/yyyy)</option>
            <option value="dd/mm/yyyy">dd/mm/yyyy</option>
            <option value="mm/dd/yyyy">mm/dd/yyyy</option>
            <option value="yyyy-mm-dd">yyyy-mm-dd (ISO)</option>
          </select>
        </label>
   
        <label class="tag">
          Mode:
          <span class="tooltip tooltip-wide" data-tooltip="Auto: Uses AI-like detection to automatically assign column roles and generate aggregates. Manual: Allows you to override column roles and add custom aggregates.">
          </span>
          <select id="mode">
            <option value="auto" selected>Auto</option>
            <option value="manual">Manual</option>
          </select>
        </label>
        <label><input id="autoExclude" type="checkbox" checked /> Auto-exclude totals/subtotals
          <span class="tooltip" data-tooltip="Automatically detect and exclude rows that appear to be totals or subtotals from aggregations."></span>
        </label>
        <button id="editRolesBtn" style="display:none">Edit column roles
          <span class="tooltip tooltip-wide" data-tooltip="Override automatic column role detection. Change how columns are classified: metric (numbers for calculation), dimension (categories for grouping), date, id, or ignore."></span>
        </button>
        <button id="addAggBtn" style="display:none">Add aggregate
          <span class="tooltip" data-tooltip="Create custom aggregations by selecting specific groupBy and metric combinations."></span>
        </button>
        <button id="clearManualBtn" style="display:none">Clear manual
          <span class="tooltip" data-tooltip="Reset all manual overrides and return to automatic mode."></span>
        </button>
        <button id="recalcBtn" style="display:none">Recalculate with roles
          <span class="tooltip" data-tooltip="Regenerate aggregates using current role assignments."></span>
        </button>
  
        <button id="autoBtn">Generate Cards
          <span class="tooltip tooltip-wide" data-tooltip="Automatically analyze your CSV data and create up to 10 interactive charts and data tables based on detected patterns and relationships."></span>
        </button>
        <span class="tag">Up to 10 aggregates</span>
      </div>
      <div class="bar" style="margin-top:8px">
        <label>Completeness threshold:
          <span class="tooltip" data-tooltip="Minimum non-null percentage for a column to be used as a dimension (0.0-1.0)."></span>
          <input id="completenessThreshold" type="number" min="0" max="1" step="0.1" value="0.6" style="width:80px" />
        </label>
        <label>Cardinality limit (ratio):
          <span class="tooltip" data-tooltip="Maximum unique values as a fraction of total rows for a column to be used as a dimension (0.0-1.0)."></span>
          <input id="cardinalityLimitRatio" type="number" min="0" max="1" step="0.1" value="0.5" style="width:80px" />
        </label>
        <label>Cardinality limit (absolute):
          <span class="tooltip" data-tooltip="Maximum absolute number of unique values for a column to be used as a dimension."></span>
          <input id="cardinalityAbsoluteLimit" type="number" min="1" value="100" style="width:80px" />
        </label>
      </div>
    </div>
  </div>

  <div class="section" data-section-id="aggregates">
    <div class="section-header">
      <h3>Aggregates</h3>
    </div>
    <div class="section-content" id="section-content-aggregates">
      <div id="results" class="grid"></div>
    </div>
  </div>

  <div class="section" id="ai-summary-section" style="display: none;" data-section-id="ai-summary">
    <div class="section-header">
      <div class="section-title-group">
        <h3>AI Summary</h3>
        <button id="regenerate-summary-btn" class="regenerate-btn" title="Regenerate AI Summary">
          ğŸ”„ Regenerate
        </button>
      </div>
    </div>
    <div class="section-content" id="section-content-ai-summary">
      <div id="ai-summary-content">
        <div id="ai-summary-loading" style="display: none;">
          <p>ğŸ¤– Generating final summary...</p>
          <div class="loading-spinner"></div>
        </div>
        <div id="ai-summary-text"></div>
      </div>
    </div>
  </div>

  <div class="section" id="ai-analysis-section" style="display: none;" data-section-id="ai-analysis">
    <div class="section-header">
      <div class="section-title-group">
        <h3>AI Analysis Chat</h3>
        <button id="refresh-context-btn" class="regenerate-btn" title="Refresh Context">
          ğŸ”„ Refresh Context
        </button>
        <button id="clear-chat-btn" class="clear-btn" title="Clear Chat History">
          ğŸ—‘ï¸ Clear
        </button>
      </div>
    </div>
    <div class="section-content" id="section-content-ai-analysis">
      <div id="ai-chat-container">
        <div id="context-status" class="context-status">
          <span class="context-indicator">ğŸ“Š</span>
          <span class="context-text">Context: Ready</span>
          <button id="toggle-context-details" class="context-toggle" title="Show context details">
            â–¼
          </button>
        </div>
        <div id="context-details" class="context-details" style="display: none;">
          <div class="context-summary">
            <div id="charts-count">Charts: 0</div>
            <div id="context-last-updated">Last updated: Never</div>
          </div>
          <div class="context-breakdown">
            <div class="context-section">
              <div class="context-section-title">ğŸ“Š Chart Data</div>
              <div id="chart-breakdown-list"></div>
            </div>
            <div class="context-section">
              <div class="context-section-title">ğŸ¤– AI Explanations</div>
              <div id="explanation-breakdown"></div>
            </div>
            <div class="context-section">
              <div class="context-section-title">ğŸ“‹ AI Summary</div>
              <div id="summary-breakdown"></div>
            </div>
            <div class="context-section">
              <div class="context-section-title">ğŸ“ˆ Dataset Info</div>
              <div id="dataset-breakdown"></div>
            </div>
          </div>
        </div>
        <div id="chat-messages" class="chat-messages">
          <div class="welcome-message">
            <div class="ai-message">
              <div class="message-avatar">ğŸ¤–</div>
              <div class="message-content">
                <p>Hello! I'm your AI assistant for data analysis. I have access to your current charts, aggregations, and data patterns. Ask me anything about your data!</p>
              </div>
            </div>
          </div>
        </div>
        <div id="chat-input-container" class="chat-input-container">
          <div id="chat-typing-indicator" class="typing-indicator" style="display: none;">
            <span class="typing-dots">
              <span></span>
              <span></span>
              <span></span>
            </span>
            AI is typing...
          </div>
          <div class="chat-input-area">
            <textarea id="chat-input" class="chat-input" placeholder="Ask about your data analysis, charts, or patterns..." rows="1"></textarea>
            <button id="send-chat-btn" class="send-btn" title="Send message" disabled>
              <span class="send-icon">â¤</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="section" data-section-id="raw-data">
    <div class="section-header">
      <h3>Raw Data</h3>
    </div>
    <div class="section-content" id="section-content-raw-data">
      <div class="table-controls">
        <label>Search: <input id="searchInput" type="text" placeholder="type to filter across all columns" style="min-width:260px"></label>
        <label>Rows per page:
          <select id="rowsPerPage">
            <option>10</option>
            <option selected>25</option>
            <option>50</option>
            <option>100</option>
          </select>
        </label>
        <div class="pager">
          <button id="prevPage">Prev</button>
          <span class="count" id="pageInfo">Page 1 / 1</span>
          <button id="nextPage">Next</button>
        </div>
        <span class="count" id="rowInfo">Showing 0â€“0 of 0</span>
        <button id="downloadFiltered">Download filtered CSV</button>
        <button id="resetExclusion">Reset auto-exclusion</button>
      </div>
      <div class="data-table-wrap">
        <table id="dataTable">
          <thead id="dataThead"></thead>
          <tbody id="dataTbody"></tbody>
          <tfoot id="dataTFoot"></tfoot>
        </table>
      </div>
    </div>
  </div>

  <div class="section" data-section-id="schema-info">
    <div class="section-header">
      <h3>Schema / Parser Info</h3>
    </div>
    <div class="section-content" id="section-content-schema-info">
      <pre id="schema" class="muted" style="white-space:pre-wrap;margin:0"></pre>
    </div>
  </div>
  <div class="section" id="ai-todo-list-section" style="display: none;" data-section-id="ai-workflow">
    <div class="section-header">
      <h3>AI Task Workflow</h3>
    </div>
    <div class="section-content" id="section-content-ai-workflow">
      <div id="ai-progress-bar-container">
        <div id="ai-progress-bar"></div>
      </div>
      <div id="ai-current-task-details"></div>
      <ul id="ai-todo-list"></ul>
    </div>
  </div>

</div>

<!-- Role Editor Modal -->
<div id="roleModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-head">
      <h3>Column Roles</h3>
      <button id="closeRoleModal" aria-label="Close">Close</button>
    </div>
    <table class="role-table">
      <thead><tr><th>Column</th><th>Detected Type</th><th>Unique</th><th>Role</th><th>Sample</th></tr></thead>
      <tbody id="roleTBody"></tbody>
    </table>
    <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <button id="saveRoles">Save roles</button>
      <div class="help-text">
        <strong>Role Definitions:</strong><br>
        <b>metric</b> - Numeric columns for calculations (sum, avg, count)<br>
        <b>dimension</b> - Categories for grouping (text with limited unique values)<br>
        <b>date</b> - Time-based fields for time series analysis<br>
        <b>id</b> - Unique identifiers (excluded from aggregations)<br>
        <b>ignore</b> - Columns to exclude from all processing
      </div>
    </div>
  </div>
</div>

<!-- Add Aggregate Modal -->
<div id="aggModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-head">
      <h3>Add Aggregate</h3>
      <button id="closeAggModal" aria-label="Close">Close</button>
    </div>
    <div class="bar">
      <label>Group by:
        <span class="tooltip" data-tooltip="Column to group data by (dimension or date columns)"></span>
        <select id="aggGroupBy"></select>
      </label>
      <label>Date bucket:
        <span class="tooltip tooltip-wide" data-tooltip="For date columns, group dates into time periods. Leave empty for exact dates."></span>
        <select id="aggBucket">
          <option value="">(none)</option>
          <option value="day">day</option>
          <option value="week">week</option>
          <option value="month">month</option>
          <option value="quarter">quarter</option>
          <option value="year">year</option>
        </select>
      </label>
      <label>Metric:
        <span class="tooltip" data-tooltip="Numeric column to aggregate (metric columns only)"></span>
        <select id="aggMetric"></select>
      </label>
      <label>Function:
        <span class="tooltip tooltip-wide" data-tooltip="sum: Add all values | avg: Calculate average | count: Count non-null values | min/max: Find minimum/maximum values | distinct_count: Count unique values"></span>
        <select id="aggFunc">
          <option value="sum">sum</option>
          <option value="avg">avg</option>
          <option value="min">min</option>
          <option value="max">max</option>
          <option value="count">count</option>
          <option value="distinct_count">distinct_count</option>
        </select>
      </label>
    </div>
    <div class="bar" style="margin-top:8px">
      <label>Chart:
        <span class="tooltip tooltip-wide" data-tooltip="Auto: System chooses best chart based on data. Bar: Good for categories. Line/Area: Best for time series. Pie/Doughnut: Good for proportions of a whole."></span>
        <select id="aggChart">
          <option value="auto">Auto</option>
          <option value="bar">Bar (vertical)</option>
          <option value="hbar">Bar (horizontal)</option>
          <option value="line">Line</option>
          <option value="area">Area</option>
          <option value="pie">Pie</option>
          <option value="doughnut">Doughnut</option>
          <option value="polarArea">Polar Area</option>
          <option value="radar">Radar</option>
        </select>
      </label>
      <label>Top-N:
        <span class="tooltip tooltip-wide" data-tooltip="Limit pie/doughnut charts to top N categories by value. Remaining items grouped as 'Others'. Helps with readability when there are many small categories."></span>
        <input id="aggTopN" type="number" min="3" max="999" value="20" style="width:90px" />
        <span class="muted small" style="display:block">Max items for pie/doughnut charts (3-999, default: 20)</span>
      </label>
      <button id="addAggConfirm">Add</button>
    </div>
    <div class="help-text">
      <strong>Tips:</strong> 
      â€¢ Use date columns with time buckets for time series analysis
      â€¢ Combine categories (dimensions) with numeric metrics for comparison charts  
      â€¢ Count function works with any column type for frequency analysis
      â€¢ Try different chart types to find the best visualization for your data
    </div>
  </div>
</div>

<!-- History Management Modal -->
<div id="historyModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-head">
      <h3>Manage History</h3>
      <button id="closeHistoryModal" aria-label="Close">Close</button>
    </div>
    <div style="display: flex; align-items: center; gap: 8px; padding: 8px; border-bottom: 1px solid var(--border);">
      <input type="checkbox" id="history-select-all" />
      <label for="history-select-all">Select All</label>
    </div>
    <div id="history-management-list" style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 16px; padding-top: 8px;">
      <!-- History items will be populated here -->
    </div>
    <div class="card-foot" style="justify-content: space-between;">
      <button id="deleteSelectedBtn" disabled style="background: #fca5a5; color: #7f1d1d; border: 1px solid #f87171;">Delete Selected</button>
      <button id="clearAllHistoryBtn" style="background: #ef4444; color: white; border: none;">Clear All History</button>
    </div>
  </div>
</div>

<!-- Removed Rows Modal -->
<div id="removedRowsModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-head">
      <h3>Rows Removed by minGroupShare</h3>
      <button id="closeRemovedRowsModal" aria-label="Close">Close</button>
    </div>
    <div class="data-table-wrap" style="max-height: 60vh;">
      <table id="removedRowsTable" class="role-table">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>


<!-- AI Settings Modal -->
<div id="aiSettingsModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="modal-card">
    <div class="modal-head">
      <h3>AI Settings</h3>
      <button id="closeAiSettingsModal" aria-label="Close">Close</button>
    </div>
    <div style="padding: 16px;">
      <div style="margin-bottom: 16px;">
        <label for="apiKeyInput" style="display: block; margin-bottom: 8px; font-weight: 500;">
          Gemini API Key:
        </label>
        <input 
          type="password" 
          id="apiKeyInput" 
          placeholder="Enter your Gemini API key..."
          style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px; margin-bottom: 8px;"
        />
        <small style="color: var(--muted); margin-bottom: 16px; display: block;">
          Your API key will be stored locally in your browser and never sent to our servers.
        </small>
      </div>
      
      <div style="margin-bottom: 16px;">
        <label for="modelSelect" style="display: block; margin-bottom: 8px; font-weight: 500;">
          Model:
        </label>
        <select 
          id="modelSelect" 
          style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: white;"
        >
          <option value="gemini-2.5-flash" selected>Gemini 2.5 Flash (Fast & Efficient)</option>
          <option value="gemini-2.5-pro">Gemini 2.5 Pro (Advanced Reasoning)</option>
          <option value="gemma-3-27b-it">Gemma 3 27B</option>
        </select>
      </div>

      <div style="margin-bottom: 16px;">
        <label for="languageSelect" style="display: block; margin-bottom: 8px; font-weight: 500;">
          Response Language:
        </label>
        <select
          id="languageSelect"
          style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: white;"
        >
          <option value="English" selected>English</option>
          <option value="Mandarin">Mandarin</option>
          <option value="Spanish">Spanish</option>
          <option value="French">French</option>
          <option value="German">German</option>
          <option value="Japanese">Japanese</option>
          <option value="Korean">Korean</option>
          <option value="Russian">Russian</option>
          <option value="Arabic">Arabic</option>
          <option value="Portuguese">Portuguese</option>
          <option value="Italian">Italian</option>
          <option value="Dutch">Dutch</option>
          <option value="Hindi">Hindi</option>
          <option value="Turkish">Turkish</option>
          <option value="Vietnamese">Vietnamese</option>
          <option value="Polish">Polish</option>
          <option value="Swedish">Swedish</option>
          <option value="Thai">Thai</option>
          <option value="Indonesian">Indonesian</option>
          <option value="Hebrew">Hebrew</option>
        </select>
      </div>
      
      <div style="margin-bottom: 16px;">
        <button
          id="testApiBtn"
          style="width: 100%; padding: 10px; background: #f3f4f6; color: var(--ink); border: 1px solid var(--border); border-radius: 6px; font-weight: 500;"
        >
          ğŸ§ª Test API Connection
        </button>
        <div id="testResult" style="margin-top: 8px; padding: 8px; border-radius: 4px; display: none;">
        </div>
      </div>
      
      <div style="display: flex; gap: 8px; justify-content: flex-end;">
        <button id="clearApiKeyBtn" style="background: #fee2e2; color: #dc2626; border-color: #fecaca;">
          Clear
        </button>
        <button id="saveApiKeyBtn" style="background: var(--accent); color: white; border-color: var(--accent);">
          Save
        </button>
      </div>
    </div>
  </div>
</div>

<div id="toast-container" class="toast-container"></div>
<div id="sr-announcer" class="sr-only" aria-live="polite" aria-atomic="true"></div>

<script type="module">
import * as Store from './ai_chart_store.js';
import { fetchWithRetry } from './ai_chart_api.js';
import { initializeAiSettingsHandlers } from './ai_chart_ai_settings_handlers.js';
import { initializeSectionToggles } from './ai_chart_section_toggle_logic.js';
import { getErpSpecificAutoPlan, getErpMetricPriority, getErpAnalysisPriority } from './ai_chart_erp_logic.js';
import { applyMasonryLayout } from './ai_chart_masonry.js';
import { getMetricPriority, selectBestMetricColumn, pickPrimaryMetric, buildErpPlan } from './ai_chart_erp_metrics.js';
import { inferType, profile, renderProfile, inferRole, detectTemporalPatterns, detectHierarchicalRelationships } from './ai_chart_profile.js';
import { parseCsvNumber, isNum, toNum, parseDateSafe } from './ai_chart_utils.js';
import { showToast } from './ai_chart_toast_system.js';
import { AITaskManager, createWorkflowManager } from './ai_chart_task_manager.js';
/* ========= utils ========= */
const $ = s => document.querySelector(s);
const stripBOM = s => (s && s.charCodeAt(0) === 0xFEFF) ? s.slice(1) : s;

// Global AI Task Manager instance
const AITasks = new AITaskManager();

// Enhanced Workflow Manager with AI Agent Integration
const WorkflowManager = createWorkflowManager(AITasks);

function updateAiTodoList(data) {
    // Handle both legacy state format and new agent format
    let state;
    if (data.agents && Array.isArray(data.agents)) {
        // New agent format - convert to legacy for backward compatibility
        const mainAgent = data.agents.find(([id, agent]) => id.includes('main_agent'));
        if (mainAgent) {
            const [agentId, agent] = mainAgent;
            const currentTaskIndex = agent.todos.findIndex(t => t.status === 'in-progress');
            const hasError = agent.todos.some(t => t.status === 'error');
            const error = hasError ? agent.todos.find(t => t.status === 'error')?.message : null;
            
            state = {
                status: agent.status,
                tasks: agent.todos.map(t => ({
                    id: t.type || t.id,
                    description: t.description,
                    status: t.status,
                    message: t.message,
                    timestamp: t.timestamp,
                    type: t.type
                })),
                currentTaskIndex,
                error: error ? new Error(error) : null,
                agents: data.agents,
                apiCalls: data.apiCalls
            };
        } else {
            return; // No main agent found
        }
    } else {
        // Legacy format
        state = data;
    }
    
    const { tasks, status, error, currentTaskIndex } = state;
    const todoList = $('#ai-todo-list');
    const container = $('#ai-todo-list-section');
    const progressBar = $('#ai-progress-bar');
    const currentTaskDetails = $('#ai-current-task-details');

    if (!todoList || !container || !progressBar || !currentTaskDetails) return;

    if (status === 'idle' || tasks.length === 0) {
        container.style.display = 'none';
        return;
    }

    container.style.display = 'block';

    // Enhanced progress calculation
    const completedTasks = tasks.filter(task => task.status === 'completed').length;
    const failedTasks = tasks.filter(task => task.status === 'error').length;
    const progress = tasks.length > 0 ? (completedTasks / tasks.length) * 100 : 0;
    
    progressBar.style.width = `${progress}%`;
    progressBar.setAttribute('aria-valuenow', progress);
    
    // Color code progress bar based on status
    progressBar.className = failedTasks > 0 ? 'progress-error' : 
                           status === 'completed' ? 'progress-complete' : 'progress-active';

    // Enhanced current task details with timing
    if (currentTaskIndex >= 0 && currentTaskIndex < tasks.length) {
        const currentTask = tasks[currentTaskIndex];
        const timeInfo = currentTask.timestamp ? 
            `Started: ${new Date(currentTask.timestamp).toLocaleTimeString()}` : '';
        
        currentTaskDetails.innerHTML = `
            <div class="current-task-info">
                <div class="task-spinner ${currentTask.type || ''}">
                    ${currentTask.type === 'api-call' ? 'ğŸŒ' : 
                      currentTask.type === 'ai-generation' ? 'ğŸ¤–' : 
                      currentTask.type === 'analysis' ? 'ğŸ“Š' : 'ğŸ”„'}
                </div>
                <div class="task-details">
                    <div class="current-task-title">${currentTask.description}</div>
                    ${currentTask.message ? `<div class="current-task-message">${currentTask.message}</div>` : ''}
                    ${timeInfo ? `<div class="current-task-time">${timeInfo}</div>` : ''}
                </div>
            </div>
        `;
    } else {
        currentTaskDetails.innerHTML = '';
    }

    // Enhanced todo list with better UI
    todoList.innerHTML = '';
    
    // Group tasks by type for better organization
    const taskGroups = tasks.reduce((groups, task) => {
        const type = task.type || 'general';
        if (!groups[type]) groups[type] = [];
        groups[type].push(task);
        return groups;
    }, {});
    
    Object.entries(taskGroups).forEach(([type, typeTasks]) => {
        // Add group header for multi-type workflows
        if (Object.keys(taskGroups).length > 1 && type !== 'general') {
            const groupHeader = document.createElement('li');
            groupHeader.className = 'task-group-header';
            groupHeader.innerHTML = `<div class="group-title">${type.toUpperCase().replace('-', ' ')}</div>`;
            todoList.appendChild(groupHeader);
        }
        
        typeTasks.forEach((task, index) => {
            const li = document.createElement('li');
            li.className = `task-item task-${task.status} task-type-${task.type || 'general'}`;
            
            const statusIcon = {
                'pending': 'â³',
                'in-progress': task.type === 'api-call' ? 'ğŸŒ' : 
                              task.type === 'ai-generation' ? 'ğŸ¤–' : 
                              task.type === 'analysis' ? 'ğŸ“Š' : 'ğŸ”„',
                'completed': 'âœ…',
                'error': 'âŒ',
                'cancelled': 'â¹ï¸',
                'retrying': 'ğŸ”„'
            }[task.status] || 'â“';
            
            const timeInfo = task.timestamp ? 
                new Date(task.timestamp).toLocaleTimeString() : '';
            
            li.innerHTML = `
                <div class="task-content">
                    <span class="task-icon ${task.status}">${statusIcon}</span>
                    <div class="task-info">
                        <div class="task-description">${task.description}</div>
                        ${task.message ? `<div class="task-message">${task.message}</div>` : ''}
                        ${timeInfo ? `<div class="task-timestamp">${timeInfo}</div>` : ''}
                    </div>
                    ${task.type === 'api-call' ? '<div class="task-badge api-badge">API</div>' : ''}
                </div>
            `;
            
            todoList.appendChild(li);
        });
    });

    // Enhanced status section with API call tracking
    const existingStatus = container.querySelector('.workflow-status');
    if (existingStatus) existingStatus.remove();
    
    const statusDiv = document.createElement('div');
    statusDiv.className = 'workflow-status';
    
    // Add enhanced API call statistics if available
    let apiStats = '';
    if (state.apiCalls && state.apiCalls.length > 0) {
        const totalCalls = state.apiCalls.length;
        const completedCalls = state.apiCalls.filter(([id, call]) => call.status === 'completed').length;
        const failedCalls = state.apiCalls.filter(([id, call]) => call.status === 'failed').length;
        const pendingCalls = state.apiCalls.filter(([id, call]) => call.status === 'pending').length;
        const retryCalls = state.apiCalls.filter(([id, call]) => call.status === 'retrying').length;
        
        // Find most recent active call for additional context
        const activeCalls = state.apiCalls.filter(([id, call]) => call.status === 'pending' || call.status === 'retrying');
        const recentActiveCall = activeCalls.length > 0 ? activeCalls[activeCalls.length - 1][1] : null;
        
        // Calculate success rate
        const successRate = totalCalls > 0 ? Math.round((completedCalls / totalCalls) * 100) : 0;
        
        apiStats = `
            <div class="api-stats">
                <div class="api-stats-header">
                    <div class="api-stats-title">ğŸŒ API Activity</div>
                    ${successRate >= 0 ? `<div class="success-rate">${successRate}% success</div>` : ''}
                </div>
                <div class="api-stats-info">
                    <div class="stat-row">
                        <span class="stat-item">Total: ${totalCalls}</span>
                        <span class="stat-item success">âœ… ${completedCalls}</span>
                        ${pendingCalls > 0 ? `<span class="stat-item pending">â³ ${pendingCalls}</span>` : ''}
                        ${retryCalls > 0 ? `<span class="stat-item retry">ğŸ”„ ${retryCalls}</span>` : ''}
                        ${failedCalls > 0 ? `<span class="stat-item error">âŒ ${failedCalls}</span>` : ''}
                    </div>
                    ${recentActiveCall ? `
                        <div class="active-call-info">
                            <span class="active-call-label">Current:</span>
                            <span class="active-call-type">${recentActiveCall.apiType || 'API call'}</span>
                            ${recentActiveCall.status === 'retrying' ? '<span class="retry-indicator">Retrying...</span>' : ''}
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    }
    
    if (status === 'completed') {
        const totalTime = tasks.length > 0 && tasks[0].timestamp ? 
            ((new Date() - new Date(tasks[0].timestamp)) / 1000).toFixed(1) : 'N/A';
        statusDiv.innerHTML = `
            <p style="color:var(--success)"><strong>âœ… Analysis completed successfully!</strong></p>
            <div class="completion-stats">
                <span>Total time: ${totalTime}s</span>
                <span>Tasks completed: ${completedTasks}/${tasks.length}</span>
            </div>
            ${apiStats}
        `;
        container.appendChild(statusDiv);
        
        // Hide the workflow section after 3 seconds
        setTimeout(() => {
            console.log('ğŸ«¥ Hiding completed workflow section');
            container.style.display = 'none';
        }, 3000);
    } else if (status === 'error') {
        const errorDetails = error?.message || 'Unknown error occurred';
        statusDiv.innerHTML = `
            <p style="color:var(--danger)"><strong>âŒ Workflow failed:</strong> ${errorDetails}</p>
            ${apiStats}
            <div class="error-actions">
                <button class="retry-button primary" data-action="retry">Retry Analysis</button>
                <button class="retry-button secondary" data-action="reset-restart">Reset & Restart</button>
            </div>
        `;
        container.appendChild(statusDiv);
    } else if (status === 'running' && currentTaskIndex > -1) {
        const currentTime = new Date().toLocaleTimeString();
        const elapsedTime = workflowTimer.getElapsed();
        const currentTask = state.tasks[currentTaskIndex];
        
        // Dynamic progress text based on current task
        const getProgressText = (task) => {
            if (!task) return 'Analysis in progress...';
            
            const taskType = task.type || '';
            const description = task.description || '';
            
            // Create dynamic text based on task type and description
            if (taskType === 'init') {
                return 'ğŸš€ Initializing analysis session...';
            } else if (taskType === 'analysis') {
                return 'ğŸ“Š Analyzing data structure and patterns...';
            } else if (taskType === 'ai-generation') {
                return 'ğŸ¤– Generating intelligent recommendations...';
            } else if (taskType === 'config') {
                return 'âš™ï¸ Applying configuration settings...';
            } else if (taskType === 'rendering') {
                return 'ğŸ¨ Rendering charts and visualizations...';
            } else if (taskType === 'ai-explanation') {
                return 'ğŸ’¡ Generating AI-powered explanations...';
            } else if (taskType === 'completion') {
                return 'âœ¨ Finalizing analysis workflow...';
            } else if (taskType === 'api-call') {
                return 'ğŸŒ Processing API request...';
            } else if (description.toLowerCase().includes('chart')) {
                return 'ğŸ“ˆ Building interactive charts...';
            } else if (description.toLowerCase().includes('explanation')) {
                return 'ğŸ’¡ Crafting detailed explanations...';
            } else if (description.toLowerCase().includes('data')) {
                return 'ğŸ“Š Processing data insights...';
            } else {
                // Use the task description or fallback to generic message
                return description ? `ğŸ”„ ${description}...` : 'Analysis in progress...';
            }
        };
        
        const progressText = getProgressText(currentTask);
        const taskIcon = {
            'init': 'ğŸš€',
            'analysis': 'ğŸ“Š', 
            'ai-generation': 'ğŸ¤–',
            'config': 'âš™ï¸',
            'rendering': 'ğŸ¨',
            'ai-explanation': 'ğŸ’¡',
            'completion': 'âœ¨',
            'api-call': 'ğŸŒ'
        }[currentTask?.type] || 'ğŸ”„';
        
        statusDiv.innerHTML = `
            <div class="running-status">
                <div class="running-info">
                    <div class="task-header">
                        <span class="task-icon">${taskIcon}</span>
                        <span class="running-text">${progressText}</span>
                    </div>
                    ${currentTask?.message ? `<div class="task-submessage">${currentTask.message}</div>` : ''}
                    <div class="time-display">
                        <span class="current-time">${currentTime}</span>
                        <span class="elapsed-time">Elapsed: ${elapsedTime}</span>
                        ${(() => {
                            const eta = workflowTimer.getEstimatedTimeRemaining(currentTaskIndex, state.tasks.length);
                            return eta ? `<span class="eta-time">${eta}</span>` : '';
                        })()}
                    </div>
                </div>
                <div class="progress-indicators">
                    <div class="task-progress">
                        <span>Step ${currentTaskIndex + 1} of ${state.tasks.length}: ${currentTask?.description || 'Processing...'}</span>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${((currentTaskIndex + 1) / state.tasks.length) * 100}%"></div>
                        </div>
                        <div class="progress-percentage">${Math.round(((currentTaskIndex + 1) / state.tasks.length) * 100)}% complete</div>
                    </div>
                </div>
                ${apiStats}
                <div class="action-buttons">
                    <button class="pause-button" data-action="pause">Pause Analysis</button>
                    <button class="cancel-button" data-action="cancel">Cancel Analysis</button>
                </div>
            </div>
        `;
        container.appendChild(statusDiv);
        
        // Update time display every second
        if (!workflowTimer.intervalId) {
            workflowTimer.onUpdate((elapsed) => {
                // Check if workflow is still running before updating UI
                const currentState = WorkflowManager.getState();
                if (currentState.status !== 'running') {
                    console.log('â¹ï¸ Stopping timer updates - workflow no longer running');
                    workflowTimer.stop();
                    return;
                }
                
                const elapsedSpan = statusDiv.querySelector('.elapsed-time');
                const currentTimeSpan = statusDiv.querySelector('.current-time');
                if (elapsedSpan) elapsedSpan.textContent = `Elapsed: ${elapsed}`;
                if (currentTimeSpan) currentTimeSpan.textContent = new Date().toLocaleTimeString();
            });
        }
    } else if (status === 'paused') {
        const currentTime = new Date().toLocaleTimeString();
        const elapsedTime = workflowTimer.getElapsed();
        statusDiv.innerHTML = `
            <div class="paused-status">
                <p style="color:var(--warning)"><strong>â¸ï¸ Analysis paused</strong></p>
                <div class="time-display">
                    <span class="elapsed-time">Elapsed: ${elapsedTime}</span>
                </div>
                ${apiStats}
                <div class="action-buttons">
                    <button class="resume-button" data-action="resume">Resume Analysis</button>
                    <button class="cancel-button" data-action="cancel">Cancel Analysis</button>
                </div>
            </div>
        `;
        container.appendChild(statusDiv);
    } else if (status === 'cancelled') {
        statusDiv.innerHTML = `
            <p style="color:var(--muted)"><strong>â¹ï¸ Workflow cancelled by user.</strong></p>
            ${apiStats}
            <button class="retry-button" data-action="restart">Restart Analysis</button>
        `;
        container.appendChild(statusDiv);
    } else {
        // Default catch-all: Clear the status message if the workflow is idle or in an unknown state
        const existingStatus = container.querySelector('.workflow-status');
        if (existingStatus) {
            existingStatus.remove();
        }
    }
}

// Subscribe the UI update function to the manager
WorkflowManager.subscribe(updateAiTodoList);

// Event delegation for WorkflowManager buttons to prevent "undefined" errors
document.addEventListener('click', (e) => {
    const action = e.target.dataset.action;
    if (!action) return;
    
    try {
        switch (action) {
            case 'retry':
                renderAggregates();
                break;
            case 'reset-restart':
                WorkflowManager.reset();
                WorkflowManager.start();
                break;
            case 'cancel':
                workflowTimer.stop();
                WorkflowManager.cancel();
                break;
            case 'pause':
                workflowTimer.stop();
                WorkflowManager.pause();
                showToast('Analysis paused', 'info');
                break;
            case 'resume':
                workflowTimer.start();
                WorkflowManager.resume();
                showToast('Analysis resumed', 'info');
                break;
            case 'restart':
                workflowTimer.reset();
                renderAggregates();
                WorkflowManager.start();
                workflowTimer.start();
                break;
        }
    } catch (error) {
        console.error('WorkflowManager action failed:', error);
        showToast?.('Action failed: ' + error.message, 'error');
    }
});

// Enhanced Gemini API integration with task tracking
function createGeminiAPIWrapper() {
    const originalFetch = window.fetch;
    
    return {
        async callGemini(agentId, taskId, endpoint, payload, apiType = 'gemini-generate') {
            const callId = WorkflowManager.trackGeminiCall(agentId, taskId, apiType, endpoint, payload);
            
            try {
                WorkflowManager.updateGeminiCall(callId, 'pending');
                
                const response = await originalFetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                WorkflowManager.updateGeminiCall(callId, 'completed', result);
                
                return result;
                
            } catch (error) {
                WorkflowManager.updateGeminiCall(callId, 'failed', null, error);
                throw error;
            }
        }
    };
}

const GeminiAPI = createGeminiAPIWrapper();

// Enhanced Workflow Timer
class WorkflowTimer {
    constructor() {
        this.startTime = null;
        this.intervalId = null;
        this.callbacks = [];
    }

    start() {
        this.startTime = Date.now();
        this.intervalId = setInterval(() => {
            const elapsed = this.getElapsed();
            this.callbacks.forEach(callback => callback(elapsed));
        }, 1000);
    }

    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
        }
    }

    getElapsed() {
        if (!this.startTime) return '00:00:00';
        const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
        const hours = Math.floor(elapsed / 3600);
        const minutes = Math.floor((elapsed % 3600) / 60);
        const seconds = elapsed % 60;
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    onUpdate(callback) {
        this.callbacks.push(callback);
    }

    getEstimatedTimeRemaining(currentTaskIndex, totalTasks) {
        if (!this.startTime || currentTaskIndex <= 0) return null;
        
        const elapsedMs = Date.now() - this.startTime;
        const avgTimePerTask = elapsedMs / (currentTaskIndex + 1);
        const remainingTasks = totalTasks - currentTaskIndex - 1;
        const estimatedRemainingMs = avgTimePerTask * remainingTasks;
        
        if (estimatedRemainingMs <= 0) return null;
        
        const minutes = Math.floor(estimatedRemainingMs / 60000);
        const seconds = Math.floor((estimatedRemainingMs % 60000) / 1000);
        
        if (minutes > 0) {
            return `~${minutes}m ${seconds}s remaining`;
        } else {
            return `~${seconds}s remaining`;
        }
    }

    reset() {
        this.stop();
        this.startTime = null;
        this.callbacks = [];
    }
}

// Enhanced API Retry Logic
class EnhancedAPIHandler {
    constructor() {
        this.maxRetries = 5;
        this.baseDelay = 1000;
        this.maxDelay = 30000;
        this.backoffMultiplier = 2;
    }

    async fetchWithExponentialBackoff(url, options, attempt = 1) {
        try {
            const response = await fetch(url, options);
            
            if (response.status === 503 || response.status === 429) {
                throw new Error(`Server overloaded (${response.status}): ${response.statusText}`);
            }
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            return response;
        } catch (error) {
            if (attempt >= this.maxRetries) {
                throw new Error(`Max retries (${this.maxRetries}) exceeded: ${error.message}`);
            }
            
            const delay = Math.min(this.baseDelay * Math.pow(this.backoffMultiplier, attempt - 1), this.maxDelay);
            const jitter = Math.random() * 0.1 * delay;
            const totalDelay = delay + jitter;
            
            console.warn(`Request failed (attempt ${attempt}/${this.maxRetries}). Retrying in ${Math.round(totalDelay)}ms... Error: ${error.message}`);
            
            await new Promise(resolve => setTimeout(resolve, totalDelay));
            return this.fetchWithExponentialBackoff(url, options, attempt + 1);
        }
    }
}

// Global instances
const workflowTimer = new WorkflowTimer();
const apiHandler = new EnhancedAPIHandler();

// Inject enhanced styles
if (!document.querySelector('#ai-workflow-enhanced-styles')) {
    const link = document.createElement('link');
    link.id = 'ai-workflow-enhanced-styles';
    link.rel = 'stylesheet';
    link.href = 'ai_chart_workflow.css';
    document.head.appendChild(link);
}

function getFormattedDateTime() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  return `${year}-${month}-${day} ${hours}:${minutes}`;
}

const nice = n => { 
  if (n==null || isNaN(n)) return ''; 
  
  // ERP standard formatting with comma separators and proper decimals
  const num = Number(n);
  
  // For very large numbers, still use abbreviations but with ERP formatting
  const a = Math.abs(num);
  if (a >= 1e15) return (num/1e12).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2}) + 'T';
  if (a >= 1e12) return (num/1e9).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2}) + 'B';
  
  // Standard ERP formatting with commas and 2 decimal places
  return num.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
}
function formatNumberFull(n) {
  const num = Number(n);
  if (!Number.isFinite(num)) return '0.00';
  return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
};
function debounce(fn, ms=250){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }
const debouncedRenderAggregates = debounce(() => { renderAggregates(); }, 300);

/**
 * Creates a canonical job key for deduplication and consistent state management.
 * Normalizes case, whitespace, and handles null/empty values consistently.
 */
function canonicalJobKey(job) {
  const { groupBy, metric, agg, dateBucket } = job;
  
  // Normalize strings: trim, lowercase, handle null/undefined
  const normalizeString = (str) => {
    if (!str || str === null || str === undefined) return '';
    return String(str).trim().toLowerCase();
  };
  
  // Normalize metric: null, undefined, empty string all become 'count'
  const normalizedMetric = !metric || metric === '' ? 'count' : normalizeString(metric);
  
  return `${normalizeString(agg)}|${normalizedMetric}|${normalizeString(groupBy)}|${normalizeString(dateBucket)}`;
}

/**
 * Deduplicates jobs array using canonical keys
 */
function deduplicateJobs(jobs) {
  if (!Array.isArray(jobs)) return [];
  
  const uniqueJobs = [];
  const seenKeys = new Set();
  
  for (const job of jobs) {
    const key = canonicalJobKey(job);
    if (!seenKeys.has(key)) {
      seenKeys.add(key);
      uniqueJobs.push(job);
    } else {
      console.log(`ğŸš« Deduplicating job: ${key}`);
    }
  }
  
  if (uniqueJobs.length !== jobs.length) {
    console.log(`ğŸ“‰ Deduplicated ${jobs.length - uniqueJobs.length} jobs, ${uniqueJobs.length} remain`);
  }
  
  return uniqueJobs;
}

function addMissingDataWarning(card, aggResult, totalRows, showMissing) {

    if (aggResult.missingCount > 0) {
        const missingShare = aggResult.missingCount / (totalRows || 1);
        // Use a configurable threshold, for now hardcode 0.1 (10%)
        const missingWarningThreshold = 0.1;
        if (missingShare > missingWarningThreshold) {
            const warning = document.createElement('div');
            warning.className = 'missing-data-warning';
            warning.style.padding = '8px 12px';
            warning.style.background = '#fffbeb';
            warning.style.border = '1px solid #fef3c7';
            warning.style.color = '#b45309';
            warning.style.fontSize = '13px';

            if (showMissing) {
                warning.innerHTML = `<strong>Note:</strong> ${aggResult.missingCount.toLocaleString()} rows (${(missingShare * 100).toFixed(1)}%) with missing group values are included in the '(Missing)' category.`;
            } else {
                warning.innerHTML = `<strong>Warning:</strong> ${aggResult.missingCount.toLocaleString()} rows (${(missingShare * 100).toFixed(1)}%) had missing values for grouping and were excluded. Use the card control "Include '(Missing)' group" to include them.`;
            }

            // Prepend to card content
            if (card.firstChild) {
                card.insertBefore(warning, card.firstChild);
            } else {
                card.appendChild(warning);
            }
        }
    }
}



// Debounced auto-save function
const debouncedAutoSave = debounce(() => {
  console.log(`ğŸ” Auto-save check: currentHistoryId=${!!window.currentHistoryId}, ROWS=${!!ROWS}`);
  if (!window.currentHistoryId || !ROWS) {
    console.log(`âŒ Auto-save skipped: missing currentHistoryId=${!!window.currentHistoryId} or ROWS=${!!ROWS}`);
    return;
  }
  const currentName = $('#history-list .history-item[data-id="' + window.currentHistoryId + '"] .name')?.textContent || 'current report';
  console.log(`ğŸ’¾ Auto-saving changes to "${currentName}"...`);
  saveCurrentStateToHistory(currentName, false); // false = update existing
}, 1500);


/* ========= state ========= */
let ROWS=null, PROFILE=null, LAST_PARSE_META=null;
let DATA_COLUMNS=[], FILTERED_ROWS=[], PAGE=1, RPP=25, QUERY="";
let SORT = { col:null, dir:'asc' };
let ROW_INCLUDED = []; // Track which rows are included in aggregations (true/false for each row)
let ROW_EXCLUSION_REASONS = {}; // Map of rowIndex to reason string
let AUTO_EXCLUDE = true;

let MODE = 'auto';
let MANUAL_ROLES = {};   // { colName: 'dimension'|'metric'|'date'|'id'|'ignore' }
let MANUAL_JOBS  = [];   // [{groupBy, metric, agg, chart, topN, dateBucket?}]
let CURRENCY_TOKENS = ['MYR','RM','Malaysian Ringgit','USD','US Dollar','SGD','SG Dollar','EUR','Euro','GBP','British Pound','JPY','Japanese Yen','CNY','Chinese Yuan','AUD','Australian Dollar','CAD','Canadian Dollar','CHF','Swiss Franc','HKD','Hong Kong Dollar','INR','Indian Rupee','KRW','South Korean Won','THB','Thai Baht','VND','Vietnamese Dong','PHP','Philippine Peso','IDR','Indonesian Rupiah'];
const CURRENCY_COLUMN_HINTS = ['ccy', 'currency', 'cur', 'curr'];

/* ========= persistence ========= */
function signatureFromHeaders(){
  if (!DATA_COLUMNS.length) return '';
  return DATA_COLUMNS.join('|') + '::' + (ROWS?ROWS.length:0);
}
const STORAGE_KEY = 'csv-agg-state-v2';
function saveState(){
  try{
    const key = signatureFromHeaders();
    localStorage.setItem(STORAGE_KEY, JSON.stringify({ MODE, MANUAL_ROLES, MANUAL_JOBS, AUTO_EXCLUDE, CURRENCY_TOKENS, dateFormat: $('#dateFormat').value, key }));
  }catch{}
}
function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY); if (!raw) return;
    const s = JSON.parse(raw);
    if (s.key && s.key === signatureFromHeaders()){
      MODE = s.MODE || MODE;
      MANUAL_ROLES = s.MANUAL_ROLES || {};
      MANUAL_JOBS = s.MANUAL_JOBS || [];
      AUTO_EXCLUDE = (typeof s.AUTO_EXCLUDE === 'boolean') ? s.AUTO_EXCLUDE : true;
      if (Array.isArray(s.CURRENCY_TOKENS) && s.CURRENCY_TOKENS.length > 0) {
        CURRENCY_TOKENS = s.CURRENCY_TOKENS;
      }
      $('#mode').value = MODE;
      $('#autoExclude').checked = AUTO_EXCLUDE;
      $('#dateFormat').value = s.dateFormat || 'auto';
      switchMode(MODE);
    }
  }catch{}
}
['change','click','input'].forEach(ev=>{ document.addEventListener(ev, debounce(saveState, 300), true); });

/* ========= parsing with smart delimiter + worker + progress ========= */
async function sniffText(file, bytes=256*1024){ const blob = await file.slice(0, bytes).text(); return stripBOM(blob || ''); }
function tryParsePreview(text, opt){
  return Papa.parse(text, { header: !!opt.header, preview: 25, skipEmptyLines: 'greedy', delimiter: opt.delimiter ?? "", quoteChar: '"', escapeChar: '"' });
}
function scorePreview(res){ const rows = res.data || []; const lens = rows.map(r => Array.isArray(r) ? r.length : (typeof r==='object' ? Object.keys(r).length : 0)); const modal = lens.length ? mode(lens) : 0; const err = (res.errors || []).length; return { modalCols: modal, errors: err }; }
function mode(arr){ const m=new Map(); let best=0, v=0; for(const x of arr){const c=(m.get(x)||0)+1; m.set(x,c); if(c>best){best=c; v=x}} return v; }
async function autoDetect(file, header=true){
  const text = await sniffText(file);
  const candidates = [",",";","\t","|"];
  let best = { delimiter:",", score:{modalCols:0, errors:Infinity} };
  for (const d of candidates){
    const res = tryParsePreview(text, { delimiter:d, header });
    const s = scorePreview(res);
    const better = (s.modalCols > best.score.modalCols) || (s.modalCols===best.score.modalCols && s.errors < best.score.errors);
    if (better) best = { delimiter:d, score:s };
  }
  return best;
}
async function parseCSV(file, delimiterChoice, header=true){
  // Validate input file
  if (!file || !file.size) {
    throw new Error('No file selected or file is empty');
  }
  
  let delimiter = ",";
  if (delimiterChoice === 'auto'){
    try {
      const autod = await autoDetect(file, header);
      delimiter = autod.delimiter;
    } catch (err) {
      console.warn('Auto-detection failed, using comma:', err);
      delimiter = ",";
    }
  } else {
    // accept either "\t" or actual tab character
    delimiter = (delimiterChoice === '\t' || delimiterChoice === '	') ? '	' : delimiterChoice;
  }
  
  $('#meta').textContent = `Parsingâ€¦ (worker) delim="${delimiter}"`;
  console.log('Starting parse with config:', { customWorker: true, header, delimiter, fileSize: file.size, fileName: file.name });
  
  return new Promise((resolve,reject)=>{
    let rowCount = 0;
    let hasCalledComplete = false;
    let isUsingWorker = true; // Track if we're using worker mode
    // Collect rows when using step() so we still return full data on complete
    const collectedRows = [];
    
    // Set up a timeout to detect if parsing gets stuck
    const timeout = setTimeout(() => {
      if (!hasCalledComplete) {
        console.error('Parse timeout - no response from parser (non-fatal, will rely on internal fallbacks)');
        // Do not reject here; worker/onerror handler will manage fallback/termination.
      }
    }, 30000); // 30 second timeout
    
    const completeHandler = (results)=>{
      if (hasCalledComplete) {
        console.warn('Complete callback called multiple times, ignoring');
        return;
      }
      hasCalledComplete = true;
      clearTimeout(timeout);
      
      console.log('Parse complete callback received:', results, 'isUsingWorker:', isUsingWorker);
      
      try {
        if (!results) {
          console.error('Results is null/undefined');
          
          // If this was the worker mode and we haven't tried fallback yet, try non-worker mode
          if (isUsingWorker) {
            console.log('Worker returned undefined, trying non-worker fallback...');
            hasCalledComplete = false; // Reset flag for retry
            isUsingWorker = false; // Mark that we're now trying non-worker
            
            const fallbackConfig = { 
              worker: false,
              header,
              skipEmptyLines:'greedy',
              dynamicTyping:false,
              delimiter,
              quoteChar:'"',
              escapeChar:'"',
              step: (results)=>{
                rowCount++;
                // Accumulate streamed row from step() so complete can return full dataset
                if (results && 'data' in results) collectedRows.push(results.data);
                if ((rowCount % 1000)===0) $('#meta').textContent = `Parsingâ€¦ ${rowCount.toLocaleString()} rows (fallback)`;
              },
              complete: completeHandler,
              error: errorHandler
            };
            
            try {
              Papa.parse(file, fallbackConfig);
              return; // Don't reject yet, wait for fallback
            } catch (fallbackErr) {
              console.error('Fallback parse failed to start:', fallbackErr);
              reject(new Error('Both worker and non-worker parsing failed to start'));
              return;
            }
          }
          
          reject(new Error('Parser returned no result - both worker and non-worker modes failed'));
          return;
        }
        
        if (typeof results !== 'object') {
          console.error('Results is not an object:', typeof results, results);
          reject(new Error('Parser returned invalid result type: ' + typeof results));
          return;
        }
        
        // Ensure we have valid data structure; when using step(), results.data is empty, so use collectedRows
        let data = (results.data && Array.isArray(results.data)) ? results.data : [];
        let meta = (results.meta && typeof results.meta === 'object') ? results.meta : {};
        let errors = (results.errors && Array.isArray(results.errors)) ? results.errors : [];
        if (!data.length && collectedRows.length) {
          // collectedRows contains per-row objects/arrays from step()
          data = collectedRows;
        }
        // Ensure delimiter is present in meta for later UI
        if (!meta || typeof meta !== 'object') meta = {};
        if (!('delimiter' in meta)) meta.delimiter = delimiter;
        
        console.log('Parsed data summary:', { dataRows: data.length, metaKeys: Object.keys(meta), errorCount: errors.length });
        
        LAST_PARSE_META = meta;
        $('#meta').textContent = `Parsed ${data.length.toLocaleString()} rows`;
        
        // Check for parsing errors first
        if (errors.length > 0) {
          console.warn('Parse errors:', errors);
          if (!data.length) {
            reject(new Error(errors[0]?.message || 'Parse failed with errors'));
            return;
          }
        }
        
        if (!data.length) {
          reject(new Error('No rows parsed - check file format and delimiter'));
          return;
        }
        
        resolve({ data, meta, errors });
      } catch (err) {
        console.error('Error in complete callback:', err);
        reject(new Error('Error processing parse results: ' + (err.message || err)));
      }
    };
    
    const errorHandler = (err, file, inputElem, reason)=>{
      clearTimeout(timeout);
      console.error('PapaParse error callback:', { err, file, inputElem, reason });
      reject(err || new Error(reason || 'Unknown parse error'));
    };

    try {
      // Prefer self-hosted worker to avoid cross-origin worker issues
      const worker = new Worker('parser.worker.js');
      isUsingWorker = true;
      const workerTimeout = setTimeout(()=>{
        console.error('Worker timeout - switching to non-worker fallback');
        try{ worker.terminate(); }catch{}
        // Start fallback
        const fallbackConfig = {
          worker: false,
          header,
          skipEmptyLines:'greedy',
          dynamicTyping:false,
          delimiter,
          quoteChar:'"',
          escapeChar:'"',
          step: (results)=>{
            rowCount++;
            if (results && 'data' in results) collectedRows.push(results.data);
            if ((rowCount % 1000)===0) $('#meta').textContent = `Parsingâ€¦ ${rowCount.toLocaleString()} rows (fallback)`;
          },
          complete: completeHandler,
          error: errorHandler
        };
        try{ Papa.parse(file, fallbackConfig); }catch(fallbackErr){
          console.error('Fallback parse failed to start after worker timeout:', fallbackErr);
          reject(new Error('Both worker and non-worker parsing failed to start'));
        }
      }, 30000);
      
      worker.onmessage = (e)=>{
        clearTimeout(workerTimeout);
        if (!e || !e.data){
          console.warn('Worker sent empty message; falling back');
          const fallbackConfig = {
            worker: false,
            header,
            skipEmptyLines:'greedy',
            dynamicTyping:false,
            delimiter,
            quoteChar:'"',
            escapeChar:'"',
            step: (results)=>{
              rowCount++;
              if (results && 'data' in results) collectedRows.push(results.data);
              if ((rowCount % 1000)===0) $('#meta').textContent = `Parsingâ€¦ ${rowCount.toLocaleString()} rows (fallback)`;
            },
            complete: completeHandler,
            error: errorHandler
          };
          try{ Papa.parse(file, fallbackConfig); }catch(fallbackErr){
            console.error('Fallback parse failed to start:', fallbackErr);
            reject(new Error('Both worker and non-worker parsing failed to start'));
          }
          return;
        }
        const msg = e.data;
        if (msg.error){
          console.warn('Worker error:', msg.message);
          const fallbackConfig = {
            worker: false,
            header,
            skipEmptyLines:'greedy',
            dynamicTyping:false,
            delimiter,
            quoteChar:'"',
            escapeChar:'"',
            step: (results)=>{
              rowCount++;
              if (results && 'data' in results) collectedRows.push(results.data);
              if ((rowCount % 1000)===0) $('#meta').textContent = `Parsingâ€¦ ${rowCount.toLocaleString()} rows (fallback)`;
            },
            complete: completeHandler,
            error: errorHandler
          };
          try{ Papa.parse(file, fallbackConfig); }catch(fallbackErr){
            console.error('Fallback parse failed to start:', fallbackErr);
            reject(new Error('Both worker and non-worker parsing failed to start'));
          }
          return;
        }
        // Optional progress support if worker posts {progress}
        if ('progress' in msg){
          $('#meta').textContent = `Parsingâ€¦ ${Number(msg.progress||0).toLocaleString()} rows (worker)`;
          return;
        }
        // Normal completion path
        try{
          const results = { data: Array.isArray(msg.data)?msg.data:[], meta: msg.meta||{}, errors: Array.isArray(msg.errors)?msg.errors:[] };
          completeHandler(results);
        } finally {
          try{ worker.terminate(); }catch{}
        }
      };
      
      worker.onerror = (err)=>{
        clearTimeout(workerTimeout);
        console.error('Worker onerror:', err?.message || err);
        const fallbackConfig = {
          worker: false,
          header,
          skipEmptyLines:'greedy',
          dynamicTyping:false,
          delimiter,
          quoteChar:'"',
          escapeChar:'"',
          step: (results)=>{
            rowCount++;
            if (results && 'data' in results) collectedRows.push(results.data);
            if ((rowCount % 1000)===0) $('#meta').textContent = `Parsingâ€¦ ${rowCount.toLocaleString()} rows (fallback)`;
          },
          complete: completeHandler,
          error: errorHandler
        };
        try{ Papa.parse(file, fallbackConfig); }catch(fallbackErr){
          console.error('Fallback parse failed to start after worker error:', fallbackErr);
          reject(new Error('Both worker and non-worker parsing failed to start'));
        }
      };
      
      const workerConfig = {
        header,
        skipEmptyLines:'greedy',
        dynamicTyping:false,
        delimiter,
        quoteChar:'"',
        escapeChar:'"'
      };
      worker.postMessage({ file, config: workerConfig });
    } catch (err) {
      clearTimeout(timeout);
      console.error('Error starting custom worker:', err);
      const fallbackConfig = {
        worker: false,
        header,
        skipEmptyLines:'greedy',
        dynamicTyping:false,
        delimiter,
        quoteChar:'"',
        escapeChar:'"',
        step: (results)=>{
          rowCount++;
          if (results && 'data' in results) collectedRows.push(results.data);
          if ((rowCount % 1000)===0) $('#meta').textContent = `Parsingâ€¦ ${rowCount.toLocaleString()} rows (fallback)`;
        },
        complete: completeHandler,
        error: errorHandler
      };
      try{ Papa.parse(file, fallbackConfig); }catch(fallbackErr){
        console.error('Fallback parse failed to start after worker constructor error:', fallbackErr);
        reject(new Error('Both worker and non-worker parsing failed to start'));
      }
    }
  });
}


/* ========= raw data table: header, sorting, filter, pagination, tfoot sums ========= */
function isLikelyCodeColumn(name){ return /(code|id|sku|account|acct|phone|tel|zip|postal|nr|no|number)$/i.test(String(name).trim()); }
function columnType(name){ const c = PROFILE?.columns?.find(x=>x.name===name); return c ? c.type : 'string'; }

// Detect rows that are likely subtotals, grand totals, or non-data rows
function isLikelyNonDataRow(row, index) {
  if (!row) return { result: true, reason: 'Row is empty' };

  const values = Object.values(row).map(v => String(v || '').trim());
  const lowerValues = values.map(v => v.toLowerCase());
  const allText = lowerValues.join(' ');

  // Rule 1: Explicit total keywords (enhanced to catch "Grand Total (SGD)")
  const totalPatterns = [
    /\b(grand\s+)?(sub)?total\b/i,
    /\bgrand\s+total\s*\(.+\)/i, // Catches "Grand Total (SGD)"
    /\bsum\b/i,
    /\btotal\s*(amount|qty|quantity|value|cost|price)\b/i,
    /\b(overall|final|net)\s+total\b/i,
    /^\s*(total|subtotal|sum)\s*:?\s*$/i
  ];
  const hasTotal = totalPatterns.some(pattern => pattern.test(allText));
  if (hasTotal) {
    const matchedValue = values.find(v => totalPatterns.some(p => p.test(v))) || 'total keyword';
    return { result: true, reason: `Contains total keyword: "${matchedValue}"` };
  }

  // Rule 2: Currency-only subtotal rows
  const currencyPatterns = new RegExp(`^(${CURRENCY_TOKENS.join('|')})$`, 'i');
  const metricPatterns = /^(price|amount|total|cost|value|sum|subtotal|qty|quantity)$/i;

  let currencyCount = 0;
  let metricCount = 0;
  let numberCount = 0;
  let meaningfulTextCount = 0;
  let currencyInfo = null;

  values.forEach((val, i) => {
    const lowerVal = lowerValues[i];
    if (!lowerVal) return;

    if (currencyPatterns.test(lowerVal)) {
      currencyCount++;
      if (!currencyInfo) {
        const colName = DATA_COLUMNS[i] || '';
        currencyInfo = {
          token: val,
          colIndex: i,
          colName: colName,
          isCurrencyHintColumn: CURRENCY_COLUMN_HINTS.some(hint => colName.toLowerCase().includes(hint)),
          isTrailingColumn: i >= (values.length - 3)
        };
      }
    } else if (metricPatterns.test(lowerVal)) {
      metricCount++;
    } else if (isNum(val) && val !== '0') {
      numberCount++;
    } else if (val.length > 3) { // A bit more strict on "meaningful"
      meaningfulTextCount++;
    }
  });

  // Condition for currency-only subtotal
  const isCurrencySubtotal = currencyCount === 1 &&
                             numberCount >= 1 &&
                             meaningfulTextCount === 0 &&
                             currencyInfo && (currencyInfo.isCurrencyHintColumn || currencyInfo.isTrailingColumn);

  if (isCurrencySubtotal) {
    return { result: true, reason: `Currency subtotal (CCY='${currencyInfo.token}')` };
  }

  // Keep original checks for separators and mostly empty rows as fallbacks
  const hasAllCapsTotal = values.some(v => /^[A-Z\s]{3,}(TOTAL|SUM|SUBTOTAL)[A-Z\s]*$/.test(v));
  const isSeparator = values.some(v => /^[-=_]{3,}$/.test(v));

  if (hasAllCapsTotal) return { result: true, reason: 'Contains ALL CAPS total keywords' };
  if (isSeparator) return { result: true, reason: 'Appears to be a separator row' };
  
  return { result: false, reason: '' };
}

// Initialize row inclusion array with smart defaults
function initializeRowInclusion() {
  if (!ROWS) return;
  ROW_EXCLUSION_REASONS = {};

  if (!AUTO_EXCLUDE) {
    ROW_INCLUDED = ROWS.map(() => true);
    console.log('Auto-exclude disabled. Including all rows.');
    return;
  }
  
  let excludedCount = 0;
  ROW_INCLUDED = ROWS.map((row, index) => {
    const exclusion = isLikelyNonDataRow(row, index);
    if (exclusion.result) {
      ROW_EXCLUSION_REASONS[index] = exclusion.reason;
      excludedCount++;
    }
    return !exclusion.result;
  });
  
  const message = `Auto-excluded ${excludedCount} rows.`;
  console.log(`ğŸ” ${message}`);
  showToast(message, 'info');
}

// Get only the rows that are included for aggregation
function getIncludedRows() {
  if (!ROWS || !ROW_INCLUDED || ROW_INCLUDED.length !== ROWS.length) {
    return ROWS; // Fallback to all rows if inclusion array not set up
  }
  
  const includedRows = ROWS.filter((row, index) => ROW_INCLUDED[index]);
  console.log(`ğŸ“Š Using ${includedRows.length} included rows out of ${ROWS.length} total rows for aggregation`);
  return includedRows;
}
function buildRawHeader(columns){
  const thead = $('#dataThead'); thead.innerHTML='';
  const tr = document.createElement('tr');
  
  // Add checkbox column header
  const checkboxTh = document.createElement('th');
  checkboxTh.className = 'sticky';
  checkboxTh.style.width = '60px';
  checkboxTh.innerHTML = `
    <div style="display: flex; flex-direction: column; align-items: center; gap: 2px;">
      <input type="checkbox" id="selectAllRows" title="Select/Deselect All" style="margin: 0;">
      <small style="font-size: 10px; color: #666;">Include</small>
    </div>
  `;
  
  // Select all functionality
  const selectAllCheckbox = checkboxTh.querySelector('#selectAllRows');
  selectAllCheckbox.addEventListener('change', (e) => {
    const checked = e.target.checked;
    ROW_INCLUDED.fill(checked);
    renderRawBody();
    // For bulk selection prefer immediate update
    renderAggregates();
    debouncedAutoSave();
    console.log(`${checked ? 'Selected' : 'Deselected'} all ${ROWS.length} rows`);
  });
  
  tr.appendChild(checkboxTh);
  
  // Add data column headers
  columns.forEach(col=>{
    const th=document.createElement('th'); th.className='sticky'; th.textContent=col;
    const s = document.createElement('span'); s.className='sort'; s.textContent='';
    th.appendChild(s);
    th.addEventListener('click', ()=>{
      if (SORT.col===col){ SORT.dir = (SORT.dir==='asc'?'desc':'asc'); }
      else { SORT.col=col; SORT.dir='asc'; }
      renderSortIndicators(); renderRawBody();
    });
    tr.appendChild(th);
  });
  thead.appendChild(tr);
  renderSortIndicators();
}
function renderSortIndicators(){
  const ths = Array.from($('#dataThead').querySelectorAll('th'));
  ths.forEach(th=>{
    const col = th.firstChild?.nodeValue || th.childNodes[0]?.textContent || '';
    const span = th.querySelector('.sort');
    if (!span) return;
    if (SORT.col===col) span.textContent = SORT.dir==='asc' ? 'â†‘' : 'â†“';
    else span.textContent = '';
  });
}
function applyFilter(){
  const q = QUERY.trim().toLowerCase();
  if (!q){ FILTERED_ROWS = ROWS; return; }
  FILTERED_ROWS = ROWS.filter(row=>{
    for (const c of DATA_COLUMNS){
      const v = row[c];
      if (v!=null && String(v).toLowerCase().includes(q)) return true;
    }
    return false;
  });
}
function sortRows(rows){
  if (!SORT.col) return rows;
  const name = SORT.col;
  const t = columnType(name);
  const dir = SORT.dir==='asc' ? 1 : -1;
  const cmp = (a,b)=>{
    const av = a[name], bv = b[name];
    if (t==='number'){
      const an = toNum(av), bn = toNum(bv);
      if (isNaN(an) && isNaN(bn)) return 0; if (isNaN(an)) return -dir; if (isNaN(bn)) return dir;
      return an < bn ? -dir : an > bn ? dir : 0;
    } else if (t==='date'){
      const an = parseDateSafe(av), bn = parseDateSafe(bv);
      if (isNaN(an) && isNaN(bn)) return 0; if (isNaN(an)) return -dir; if (isNaN(bn)) return dir;
      return an < bn ? -dir : an > bn ? dir : 0;
    } else {
      const as = (av==null?'':String(av)).toLowerCase();
      const bs = (bv==null?'':String(bv)).toLowerCase();
      return as < bs ? -dir : as > bs ? dir : 0;
    }
  };
  return rows.map((r,i)=>({r,i})).sort((A,B)=> cmp(A.r,B.r) || (A.i - B.i)).map(A=>A.r);
}
function renderTFootSums(){
  const tfoot = $('#dataTFoot'); tfoot.innerHTML='';
  if (!FILTERED_ROWS?.length){ return; }
  const tr = document.createElement('tr');
  
  // Add placeholder for checkbox column
  const placeholderTd = document.createElement('td');
  placeholderTd.style.width = '60px'; // Match header checkbox column
  tr.appendChild(placeholderTd);

  DATA_COLUMNS.forEach(col=>{
    const td = document.createElement('td');
    const t = columnType(col);
    if (t==='number' && !isLikelyCodeColumn(col)){
      let sum = 0;
      // Only sum rows that are both filtered AND included
      for (const r of FILTERED_ROWS){ 
        const originalIndex = ROWS.findIndex(row => row === r);
        if (originalIndex !== -1 && ROW_INCLUDED[originalIndex]) {
          const n = toNum(r[col]); 
          if (!isNaN(n)) sum += n; 
        }
      }
      td.textContent = 'Î£ ' + nice(sum);
    } else { td.textContent = ''; }
    tr.appendChild(td);
  });
  tfoot.appendChild(tr);
}
function renderRawBody(){
  const tbody = $('#dataTbody'); tbody.innerHTML='';
  const total = FILTERED_ROWS.length, pages = Math.max(1, Math.ceil(total / RPP));
  PAGE = Math.min(PAGE, pages);
  const sorted = sortRows(FILTERED_ROWS);
  const start = (PAGE-1)*RPP, end = Math.min(start+RPP, total);
  
  // Function to highlight search terms in text
  function highlightText(text, query) {
    if (!query || !query.trim()) return text;
    // Escape HTML in the text first to prevent XSS
    const safeText = String(text).replace(/[&<>"']/g, function(m) {
      return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m];
    });
    const escapedQuery = query.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(${escapedQuery})`, 'gi');
    return safeText.replace(regex, '<mark>$1</mark>');
  }
  
  for (let i=start;i<end;i++){
    const r = sorted[i];
    const originalIndex = ROWS.indexOf(r); // Find original index for checkbox state
    const tr = document.createElement('tr');
    
    // Add checkbox column
    const checkboxTd = document.createElement('td');
    checkboxTd.style.textAlign = 'center';
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = ROW_INCLUDED[originalIndex] || false;
    checkbox.style.margin = '0';
    
    // Add visual indicator for auto-detected non-data rows
    const exclusionReason = ROW_EXCLUSION_REASONS[originalIndex];
    if (exclusionReason) {
      checkboxTd.style.backgroundColor = '#fff3cd';
      checkboxTd.title = `Excluded: ${exclusionReason}`;
      tr.style.backgroundColor = '#fff3cd';
      tr.style.opacity = '0.7';
    }
    
    checkbox.addEventListener('change', (e) => {
      ROW_INCLUDED[originalIndex] = e.target.checked;
      console.log(`Row ${originalIndex + 1} ${e.target.checked ? 'included' : 'excluded'} for aggregation`);
      
      // Update select all checkbox state
      const allChecked = ROW_INCLUDED.every(inc => inc);
      const noneChecked = ROW_INCLUDED.every(inc => !inc);
      const selectAllCheckbox = document.getElementById('selectAllRows');
      if (selectAllCheckbox) {
        selectAllCheckbox.checked = allChecked;
        selectAllCheckbox.indeterminate = !allChecked && !noneChecked;
      }
      
      // Update Raw Data table footer sums when inclusion changes
      renderTFootSums();
      
      debouncedRenderAggregates();
      debouncedAutoSave();
    });
    
    checkboxTd.appendChild(checkbox);
    tr.appendChild(checkboxTd);
    
    // Add data columns
    DATA_COLUMNS.forEach(c=>{
      const td = document.createElement('td');
      let v = r[c];
      const textValue = (v==null? '' : String(v));
      
      // Apply highlighting if there's a search query
      const searchTerm = QUERY ? QUERY.trim() : '';
      if (searchTerm) {
        td.innerHTML = highlightText(textValue, searchTerm);
      } else {
        td.textContent = textValue;
      }
      
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  }
  $('#pageInfo').textContent = `Page ${PAGE} / ${pages}`;
  $('#rowInfo').textContent = `Showing ${total? start+1:0}â€“${end} of ${total}${(ROWS && ROWS.length!==total) ? ` (filtered from ${ROWS.length})` : ''}`;
  $('#prevPage').disabled = PAGE<=1;
  $('#nextPage').disabled = PAGE>=pages;
  renderTFootSums();
}
const onSearch = debounce(()=>{ QUERY = $('#searchInput').value; PAGE=1; applyFilter(); renderRawBody(); }, 200);

/* ========= roles + auto plan (no-AI) ========= */
// Enhanced Pattern Recognition for Business Data Types



function autoPlan(profile, rows, excludedDimensions = []) {
    const columns = profile.columns.map(c => c.name);
    const erpPriority = getErpAnalysisPriority(columns);

    if (erpPriority && erpPriority.metrics.length > 0 && erpPriority.dimensions.length > 0) {
        console.log('[Debug] autoPlan: Using ERP priority plan:', JSON.stringify(erpPriority, null, 2));
        const jobs = [];
        const primaryMetric = erpPriority.metrics[0];
        console.log('[Debug] autoPlan: Primary metric selected:', JSON.stringify(primaryMetric, null, 2));
        
        erpPriority.dimensions.forEach(dim => {
            if (dim && columns.includes(dim)) {
                jobs.push({
                    groupBy: dim,
                    metric: primaryMetric.type === 'derived' ? primaryMetric.baseMetric : primaryMetric.name,
                    agg: 'sum'
                });
            }
        });
        return { jobs: deduplicateJobs(jobs).slice(0, 10), charts: [] };
    }

    console.log('[autoPlan] Starting plan, excluding:', excludedDimensions);
  console.log('[Debug] autoPlan: Available columns for metric selection:', profile.columns.map(c => c.name));
  let roles = profile.columns.map(c => ({ col:c, ...inferRole(c, profile, rows) }));
  console.log('[Debug] autoPlan: All inferred roles:', roles.map(r => ({ name: r.col.name, role: r.role, category: r.category, priority: r.priority, erp: r.erp })));
  if (excludedDimensions.length > 0) {
    roles = roles.filter(r => !excludedDimensions.includes(r.col.name));
  }
  
  // Enhanced role categorization with business intelligence
  const dims = roles.filter(x => x.role==='dimension' && !x.unsuitable).map(x => ({ ...x, col: x.col }))
    .sort((a, b) => b.completeness - a.completeness || a.cardinality - b.cardinality);
  const dates = roles.filter(x => x.role==='date' && !x.unsuitable && x.completeness > 0.2).map(x => ({ ...x, col: x.col }))
    .sort((a, b) => b.completeness - a.completeness);
  const metricsStrong = roles.filter(x => x.role==='metric:strong').map(x => ({ ...x, col: x.col }));
  const metrics = roles.filter(x => x.role==='metric' || x.role==='metric:strong').map(x => ({ ...x, col: x.col }));
  
  // Sort strong metrics by the priority assigned in inferRole
  metricsStrong.sort((a, b) => {
    const priorities = { critical: 3, high: 2, normal: 1, low: 0 };
    const priorityA = priorities[a.priority] || 0;
    const priorityB = priorities[b.priority] || 0;
    return priorityB - priorityA;
  });
  console.log('[Debug] autoPlan: Sorted strong metrics:', metricsStrong.map(m => `${m.col.name} (priority: ${m.priority})`));
  
  // Detect hierarchical relationships
  const hierarchicalRels = detectHierarchicalRelationships(profile);
  
  // Categorize dimensions by business context
  const businessDims = {
    financial: dims.filter(d => d.category === 'financial'),
    location: dims.filter(d => d.category === 'location'),
    contact: dims.filter(d => d.category === 'contact'),
    status: dims.filter(d => d.category === 'status'),
    hierarchy: dims.filter(d => d.category === 'hierarchy'),
    temporal: dims.filter(d => d.category === 'temporal'),
    general: dims.filter(d => d.category === 'general' || !d.category)
  };
  
  // Prioritize metrics by business importance
  const financialMetrics = metricsStrong.filter(m => m.category === 'financial');
  const quantityMetrics = metricsStrong.filter(m => m.category === 'quantity');
  const generalMetrics = metricsStrong.filter(m => m.category === 'general' || !m.category);
  
  // Select primary metric with enhanced business logic
  const primary = financialMetrics[0]?.col || quantityMetrics[0]?.col ||
                  metricsStrong[0]?.col || pickPrimaryMetric(profile, rows);
  console.log('[autoPlan] Final primary metric selected:', primary?.name);
  const jobs = []; const charts = [];
  
  // Enhanced temporal analysis with business patterns - only if date has good data
  if (dates.length && primary && dates[0].completeness >= 0.5) {
    const dateCol = dates[0];
    const bucket = autoBucket(rows, dateCol.col.name);
    jobs.push({
      groupBy: dateCol.col.name,
      metric: primary.name,
      agg: dateCol.category === 'financial' ? 'sum' : 'sum',
      dateBucket: bucket,
      temporal: dateCol.temporal
    });
    charts.push({
      useJob: jobs.length-1,
      preferredType: 'line',
      title: `${primary.name} over ${dateCol.col.name}`,
      priority: 'critical'
    });
  }
  
  // Prioritized dimension analysis based on business context
  const prioritizedDims = [
    ...businessDims.status.slice(0,1),      // Status/Category (highest business value)
    ...businessDims.location.slice(0,1),    // Geographic analysis
    ...businessDims.hierarchy.slice(0,1),   // Organizational structure
    ...businessDims.temporal.slice(0,1),    // Temporal categories
    ...businessDims.general.slice(0,2)      // General dimensions
  ].slice(0,3);
  
  prioritizedDims.forEach(d => {
    if (primary && d.col) {
      // Financial metrics use sum, others use appropriate aggregation
      const aggType = d.category === 'financial' ? 'sum' : 'sum';
      jobs.push({
        groupBy: d.col.name,
        metric: primary.name,
        agg: aggType,
        category: d.category,
        priority: d.priority
      });
      
      // Smart chart type selection based on data category
      let chartType = 'bar';
      if (d.category === 'status' && d.col.unique <= 8) chartType = 'pie';
      else if (d.category === 'location') chartType = 'bar';
      else if (d.category === 'hierarchy') chartType = 'hbar';
      else if (d.col.unique <= 8) chartType = 'pie';
      
      charts.push({
        useJob: jobs.length-1,
        preferredType: chartType,
        title: `${primary.name} by ${d.col.name}`,
        category: d.category,
        priority: d.priority === 'high' ? 'high' : 'normal'
      });
      
      // Add average analysis for high-value dimensions
      if (d.priority === 'high' || d.category === 'location') {
        jobs.push({
          groupBy: d.col.name,
          metric: primary.name,
          agg: 'avg',
          category: d.category,
          priority: d.priority
        });
        charts.push({
          useJob: jobs.length-1,
          preferredType: 'hbar',
          title: `avg ${primary.name} by ${d.col.name}`,
          category: d.category,
          priority: 'normal'
        });
      }
    }
    
    // Count analysis for all dimensions (only when no primary metric is available)
    if (d.col && !primary) {
      jobs.push({
        groupBy: d.col.name,
        metric: null,
        agg: 'count',
        category: d.category
      });
      charts.push({
        useJob: jobs.length - 1,
        preferredType: d.col.unique <= 8 ? 'pie' : 'bar',
        title: `count(*) by ${d.col.name}`,
        category: d.category,
        priority: 'low'
      });
    }
  });
  
  // Secondary metric analysis with business context
  const secondaryMetrics = [
    ...quantityMetrics.filter(m => m.col.name !== primary?.name).slice(0,1),
    ...generalMetrics.filter(m => m.col.name !== primary?.name).slice(0,1)
  ];
  
  if (secondaryMetrics.length && prioritizedDims.length) {
    const secondMetric = secondaryMetrics[0];
    const topDim = prioritizedDims[0];
    if (secondMetric.col && topDim.col) {
      jobs.push({
        groupBy: topDim.col.name,
        metric: secondMetric.col.name,
        agg: secondMetric.category === 'financial' ? 'sum' : 'sum',
        category: secondMetric.category
      });
      charts.push({
        useJob: jobs.length-1,
        preferredType: 'bar',
        title: `${secondMetric.col.name} by ${topDim.col.name}`,
        category: secondMetric.category,
        priority: 'normal'
      });
    }
  }
  
  // Apply canonical deduplication before returning
  const deduplicatedJobs = deduplicateJobs(jobs);
  console.log('[Debug] autoPlan: Final generated jobs:', JSON.stringify(deduplicatedJobs.slice(0,10), null, 2));
  return { jobs: deduplicatedJobs.slice(0,10), charts, hierarchicalRels, businessContext: businessDims };
}

function autoBucket(rows, dateCol){
  const ds = rows.map(r=>parseDateSafe(r[dateCol])).filter(x=>!Number.isNaN(x));
  if (!ds.length) return '';
  const spanDays = (Math.max(...ds)-Math.min(...ds))/86400000;
  if (spanDays > 400) return 'month';
  if (spanDays > 120) return 'week';
  return 'day';
}

/* ========= aggregates ========= */
function bucketDate(d, bucket){
  const t = parseDateSafe(d); if (Number.isNaN(t)) return null;
  const dt = new Date(t);
  const y = dt.getUTCFullYear(), m = dt.getUTCMonth()+1, day = dt.getUTCDate();
  if (bucket==='year') return `${y}`;
  if (bucket==='quarter') return `${y}-Q${Math.floor((m-1)/3)+1}`;
  if (bucket==='month') return `${y}-${String(m).padStart(2,'0')}`;
  if (bucket==='week'){
    // Calculate ISO 8601 week number
    // Create a new date for the given date (to avoid modifying the original)
    const date = new Date(Date.UTC(y, dt.getUTCMonth(), day));
    
    // Set to nearest Thursday (current date + 4 - current day number)
    // Make Sunday's day number 7 (convert Sunday from 0 to 7)
    const dayNum = date.getUTCDay() || 7;
    date.setUTCDate(date.getUTCDate() + (4 - dayNum));
    
    // Get first day of year
    const yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
    
    // Calculate full weeks to nearest Thursday
    const weekNum = Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
    
    // Return week number in format YYYY-WXX
    return `${date.getUTCFullYear()}-W${String(weekNum).padStart(2,'0')}`;
  }
  return `${y}-${String(m).padStart(2,'0')}-${String(day).padStart(2,'0')}`; // day
}

function normalizeGroupKey(v, type) {
  if (v === null || v === undefined) return null;
  if (typeof v === 'string') {
    const s = v.trim();
    if (!s) return null;
    if (/^(n\/a|na|unknown|null|-|none)$/i.test(s)) return null;
    return s;
  }
  if (type === 'date') {
    const d = parseDateSafe(v);
    return isNaN(d) ? null : new Date(d).toISOString().split('T')[0];
  }
  return v;
}
function groupAgg(rows, groupBy, metric, agg, dateBucket='', filterConfig = { mode: 'share', value: 0 }, showMissing = true){
  console.log(`[Debug] groupAgg called with:`, { groupBy, metric, agg, dateBucket });
  if (metric && !PROFILE.columns.some(c => c.name === metric)) {
    console.warn(`[Debug] groupAgg: Metric "${metric}" not found in profile columns. Aggregation may fail.`);
  }
  const m = new Map();
  const isDateCol = columnType(groupBy)==='date';
  let missingCount = 0;
  const missingRows = [];
  let rawRowsCount = rows.length;
  let missingSum = 0; // sum of metric for rows with missing group key (or invalid bucket)
  const collectForMissing = (r) => {
    // Only compute missingSum when aggregation uses a metric-like summation
    if (agg === 'sum' || (agg === 'count' && !metric)) {
      // For count with no metric, we fallback to ERP metric selection
      if (!metric) {
        const numericCols = Object.keys(r).filter(col => {
          const val = r[col];
          return val !== null && val !== '' && isFinite(toNum(val));
        });
        const firstNumeric = selectBestMetricColumn(numericCols);
        if (firstNumeric) {
          const v = toNum(r[firstNumeric]);
          if (isFinite(v)) missingSum += v;
        }
      } else {
        const v = toNum(r[metric]);
        if (isFinite(v)) missingSum += v;
      }
    } else if (agg === 'avg' || agg === 'min' || agg === 'max') {
      const v = toNum(r[metric]);
      if (isFinite(v)) missingSum += v;
    }
  };

  for (const r of rows){
    let g = r[groupBy];
    if (isDateCol && dateBucket){
      const b = bucketDate(g, dateBucket);
      if (b==null) {
        missingCount++;
        missingRows.push(r);
        collectForMissing(r);
        if (!showMissing) continue;
      }
      g = b;
    }
    const key = normalizeGroupKey(g, isDateCol && !dateBucket ? 'date' : 'string');
    if (key === null) {
      missingCount++;
      missingRows.push(r);
      collectForMissing(r);
      if (!showMissing) continue;
    }
    const finalKey = key === null ? '(Missing)' : key;
    if (agg === 'count') {
      // For count aggregations, always count the row regardless of metric value
      m.set(finalKey, (m.get(finalKey)||0) + 1);
    } else {
      const v = toNum(r[metric]);
      if (isFinite(v)){
        if (!m.has(finalKey)) m.set(finalKey, []);
        m.get(finalKey).push(v);
      }
    }
  }
  const out = [];
  for (const [k, arr] of m){
    let val = 0;
    if (agg==='count') {
      if (Array.isArray(arr)) {
        val = arr.reduce((a,b)=>a+b,0);
      } else {
        val = arr;
      }
    }
    else if (!arr.length) continue;
    else if (agg==='sum') val = arr.reduce((a,b)=>a+b,0);
    else if (agg==='avg') val = arr.reduce((a,b)=>a+b,0)/arr.length;
    else if (agg==='min') val = Math.min(...arr);
    else if (agg==='max') val = Math.max(...arr);
    else if (agg==='distinct_count') val = new Set(arr).size;
    out.push([k, val]);
  }
  if (isDateCol || dateBucket) {
    // Chronological order for date columns and date buckets
    out.sort((a, b) => {
      const ak = String(a[0] ?? '');
      const bk = String(b[0] ?? '');
      
      // For date buckets, parse the formatted strings back to dates for proper sorting
      if (dateBucket) {
        // Handle different bucket formats
        let dateA, dateB;
        
        if (dateBucket === 'year') {
          // Format: "YYYY"
          dateA = new Date(`${ak}-01-01`);
          dateB = new Date(`${bk}-01-01`);
        } else if (dateBucket === 'quarter') {
          // Format: "YYYY-QX"
          const [, yearA, quarterA] = ak.match(/^(\d+)-Q(\d)$/) || [];
          const [, yearB, quarterB] = bk.match(/^(\d+)-Q(\d)$/) || [];
          if (yearA && quarterA && yearB && quarterB) {
            dateA = new Date(Date.UTC(parseInt(yearA), (parseInt(quarterA) - 1) * 3, 1));
            dateB = new Date(Date.UTC(parseInt(yearB), (parseInt(quarterB) - 1) * 3, 1));
          } else {
            // Fallback to string comparison
            return ak < bk ? -1 : ak > bk ? 1 : 0;
          }
        } else if (dateBucket === 'month') {
          // Format: "YYYY-MM"
          const [, yearA, monthA] = ak.match(/^(\d+)-(\d{2})$/) || [];
          const [, yearB, monthB] = bk.match(/^(\d+)-(\d{2})$/) || [];
          if (yearA && monthA && yearB && monthB) {
            dateA = new Date(Date.UTC(parseInt(yearA), parseInt(monthA) - 1, 1));
            dateB = new Date(Date.UTC(parseInt(yearB), parseInt(monthB) - 1, 1));
          } else {
            // Fallback to string comparison
            return ak < bk ? -1 : ak > bk ? 1 : 0;
          }
        } else if (dateBucket === 'week') {
          // Format: "YYYY-WXX"
          const [, yearA, weekA] = ak.match(/^(\d+)-W(\d{2})$/) || [];
          const [, yearB, weekB] = bk.match(/^(\d+)-W(\d{2})$/) || [];
          if (yearA && weekA && yearB && weekB) {
            // Convert week number to date (Monday of that week)
            dateA = new Date(Date.UTC(parseInt(yearA), 0, 4)); // January 4th (close to first Monday)
            dateA.setDate(dateA.getDate() - ((dateA.getDay() + 6) % 7) + (parseInt(weekA) - 1) * 7);
            
            dateB = new Date(Date.UTC(parseInt(yearB), 0, 4)); // January 4th (close to first Monday)
            dateB.setDate(dateB.getDate() - ((dateB.getDay() + 6) % 7) + (parseInt(weekB) - 1) * 7);
          } else {
            // Fallback to string comparison
            return ak < bk ? -1 : ak > bk ? 1 : 0;
          }
        } else {
          // Day format: "YYYY-MM-DD"
          const partsA = ak.split('-');
          const partsB = bk.split('-');
          if (partsA.length === 3 && partsB.length === 3) {
            dateA = new Date(Date.UTC(parseInt(partsA[0]), parseInt(partsA[1]) - 1, parseInt(partsA[2])));
            dateB = new Date(Date.UTC(parseInt(partsB[0]), parseInt(partsB[1]) - 1, parseInt(partsB[2])));
          } else {
            // Fallback to string comparison
            return ak < bk ? -1 : ak > bk ? 1 : 0;
          }
        }
        
        // Compare the parsed dates
        if (dateA && dateB) {
          return dateA.getTime() - dateB.getTime();
        } else {
          // Fallback to string comparison if parsing failed
          return ak < bk ? -1 : ak > bk ? 1 : 0;
        }
      } else {
        // For regular date columns, parse the values as dates
        const dateA = parseDateSafe(ak);
        const dateB = parseDateSafe(bk);
        
        // If both are valid dates, compare them
        if (!Number.isNaN(dateA) && !Number.isNaN(dateB)) {
          return dateA - dateB;
        } else {
          // Fallback to string comparison
          return ak < bk ? -1 : ak > bk ? 1 : 0;
        }
      }
    });
  } else {
    // Default: sort by metric descending for non-date columns
    out.sort((a,b)=> (Number(b[1]||0) - Number(a[1]||0)));
  }
  // Simplified header construction
  let headerAgg = `${agg}(${metric || '*'})`;
  
  // Calculate raw data sum from all rows before any processing
  let rawDataSum = 0;
  const metricForRawSum = (row) => {
    if (agg === 'sum' || (agg === 'count' && !metric)) {
      if (!metric) {
        const numericCols = Object.keys(row).filter(col => {
          const val = row[col];
          return val !== null && val !== '' && isFinite(toNum(val));
        });
        const firstNumeric = selectBestMetricColumn(numericCols);
        if (firstNumeric) return toNum(row[firstNumeric]);
        return NaN;
      } else {
        return toNum(row[metric]);
      }
    } else if (agg === 'avg' || agg === 'min' || agg === 'max') {
      return toNum(row[metric]);
    }
    return NaN;
  };
  
  for (const r of rows) {
    const v = metricForRawSum(r);
    if (isFinite(v)) rawDataSum += v;
  }
  
  const totalSum = out.reduce((sum, row) => sum + row[1], 0);
  let filteredOut = out;
  let removedRows = [];

  if (filterConfig && filterConfig.value > 0) {
    if (filterConfig.mode === 'share') {
      const minGroupShare = filterConfig.value;
      filteredOut = out.filter(row => (row[1] / (totalSum || 1)) >= minGroupShare);
      removedRows = out.filter(row => (row[1] / (totalSum || 1)) < minGroupShare);
    } else if (filterConfig.mode === 'value') {
      const minValue = filterConfig.value;
      filteredOut = out.filter(row => row[1] >= minValue);
      removedRows = out.filter(row => row[1] < minValue);
    }
  }

  return {
    header:[isDateCol && dateBucket ? `${groupBy} (${dateBucket})` : groupBy, headerAgg],
    rows: filteredOut,
    missingCount,
    missingRows,
    totalSum,
    missingSum,
    rawDataSum,
    rawRowsCount,
    groupsBeforeFilter: out.length,
    removedRows
  };
}

/* ========= charting (FIXED HEIGHT + SAFE REDRAW + MORE TYPES) ========= */
const chartRegistry = new WeakMap(); // canvas -> { chart, ro }
function computeChartConfig(agg, typePref, topN, options = {}){
  const { noAnimation = false } = options;
  const total = agg.rows.length;
 
  // Determine type first
  let type='bar', indexAxis='x', fill=false;
  if (typePref==='hbar'){ type='bar'; indexAxis='y'; }
  else if (typePref==='line'){ type='line'; }
  else if (typePref==='area'){ type='line'; fill=true; }
  else if (['pie','doughnut','polarArea','radar'].includes(typePref)){ type=typePref; }
  else if (typePref==='auto'){ type = (total<=8 ? 'pie' : 'bar'); }
 
  const isCircular = (type==='pie' || type==='doughnut' || type==='polarArea' || type==='radar');
 
  // Limit categories when Top-N provided (applies to circular and bar charts); line/area keep full series
let rows=[...agg.rows];
const limit = Number(topN);
if (Number.isFinite(limit) && limit>0 && rows.length>limit && (isCircular || type==='bar')){
  const head = rows.slice(0, limit);
  const other = rows.slice(limit).reduce((a,b)=> a + (+b[1] || 0), 0);
  rows = other ? [...head, ['Other', other]] : head;
}
 
  const labels=rows.map(r=>String(r[0]));
  const values = rows.map(r => { const n = toNum(r[1]); return Number.isFinite(n) ? n : 0; });
 
  return {
    type,
    data:{
      labels,
      datasets:[{
        label: agg.header[1],
        data: values,
        fill,
        tension: 0.4,
        borderColor: '#2563eb',
        backgroundColor: (type === 'pie' || type === 'doughnut')
          ? [
            '#2563eb', '#3b82f6', '#60a5fa', '#93c5fd', '#bfdbfe',
            '#10b981', '#34d399', '#6ee7b7', '#a7f3d0', '#d1fae5',
            '#8b5cf6', '#a78bfa', '#c4b5fd', '#ddd6fe', '#ede9fe',
            '#f59e0b', '#fbbf24', '#fcd34d', '#fde68a', '#fef3c7'
          ]
          : 'rgba(37, 99, 235, 0.1)',
        pointBackgroundColor: '#2563eb',
        pointRadius: 4,
        borderWidth: 2,
        borderRadius: type === 'bar' ? 4 : 0,
        borderSkipped: false
      }]
    },
    options:{
      responsive:true,
      maintainAspectRatio:false,
      animation: noAnimation ? false : {
        duration: 1000,
        easing: 'easeOutQuart'
      },
      // Pin pixel ratio to avoid apparent CSS growth when DPR changes
      devicePixelRatio: 1,
      indexAxis,
      plugins:{
        legend:{
          display: isCircular || labels.length<=20,
          labels: {
            font: {
              size: 12,
              family: 'system-ui, Segoe UI, Arial, sans-serif'
            },
            padding: 20,
            usePointStyle: true,
            pointStyle: 'circle'
          }
        },
        tooltip:{
          backgroundColor: 'rgba(255, 255, 255, 0.95)',
          titleColor: '#0b1220',
          bodyColor: '#0b1220',
          borderColor: '#e2e8f0',
          borderWidth: 1,
          cornerRadius: 8,
          displayColors: true,
          callbacks:{
            label: ctx => {
              const v = ctx.parsed?.y ?? ctx.parsed ?? ctx.raw;
              return `${ctx.dataset.label}: ${nice(v)}`;
            }
          }
        },
        // Enable point decimation for line/area to keep performance with many points
        decimation:{ enabled: (type==='line'), algorithm:'lttb' }
      },
      scales: isCircular ? {} : {
        x: {
          beginAtZero: true,
          grid: {
            color: 'rgba(226, 232, 240, 0.3)',
            drawBorder: true
          },
          ticks: {
            autoSkip: true,
            maxRotation: 0,
            font: {
              size: 11,
              family: 'system-ui, Segoe UI, Arial, sans-serif'
            },
            callback: (indexAxis === 'x') ? undefined : function(value) {
              // Format numeric values on x-axis (for horizontal bar charts)
              return nice(value);
            }
          }
        },
        y: {
          beginAtZero: true,
          grid: {
            color: 'rgba(226, 232, 240, 0.3)',
            drawBorder: true
          },
          ticks: {
            autoSkip: true,
            maxRotation: 0,
            font: {
              size: 11,
              family: 'system-ui, Segoe UI, Arial, sans-serif'
            },
            callback: (indexAxis === 'y') ? undefined : function(value) {
              // Format numeric values on y-axis (for vertical bar charts)
              return nice(value);
            }
          }
        }
      }
    }
  };
}
function ensureChart(canvas, cfg, shouldResize=false){
  const rec = chartRegistry.get(canvas);
  let chart = rec ? rec.chart : null;
  let ro = rec ? rec.ro : null;

  // Check if chart type has changed or if chart doesn't exist
  if (!chart || chart.config.type !== cfg.type) {
    if (chart) {
      try { chart.destroy(); } catch {}
      if (ro) { try { ro.disconnect(); } catch {} }
      chartRegistry.delete(canvas);
    }
    // Create new chart
    chart = new Chart(canvas.getContext('2d'), cfg);
    ro = new ResizeObserver(()=>{ if (chart) chart.resize(); });
    const parent = canvas.parentElement; if (parent) ro.observe(parent);
    chartRegistry.set(canvas, { chart, ro });
  } else {
    // Update existing chart
    chart.data.labels = cfg.data.labels;
    chart.data.datasets[0].data = cfg.data.datasets[0].data;
    
    // Update dataset properties that might change (like fill for line/area switch)
    Object.assign(chart.data.datasets[0], cfg.data.datasets[0]);
    
    // Merge options to allow for dynamic updates without full recreation
    Object.assign(chart.options, cfg.options);
    
    // Only force a resize when CSS dimension actually changed
    if (shouldResize) chart.resize();
    chart.update('none'); // snappier redraw without animation
  }
  return chart;
}
function renderChartCard(agg, chartsContainer, defaultType='auto', defaultTopN=20, titleForFile='chart', options = {}){
  const { noAnimation = false } = options;
  const c = document.createElement('div'); c.className='chart-card';
  const head = document.createElement('div'); head.className='chart-head';
  const left = document.createElement('div'); left.className='small muted'; left.textContent = `Chart for: ${agg.header[1]} by ${agg.header[0]}`;
  
  // Create chart controls container
  const controls = document.createElement('div'); controls.className='chart-controls';
  
  const typeSel = document.createElement('select');
  typeSel.innerHTML = `
    <option value="auto">Auto</option>
    <option value="bar">Bar (vertical)</option>
    <option value="hbar">Bar (horizontal)</option>
    <option value="line">Line</option>
    <option value="area">Area</option>
    <option value="pie">Pie</option>
    <option value="doughnut">Doughnut</option>
    <option value="polarArea">Polar Area</option>
    <option value="radar">Radar</option>`;
  typeSel.value = defaultType;
  
  const topNInput = document.createElement('input');
  topNInput.type='number';
  topNInput.min='3';
  topNInput.max='999';
  topNInput.value=String(defaultTopN);
  topNInput.placeholder='Top-N';
  
  const editBtn = document.createElement('button');
  editBtn.textContent='Edit';
  editBtn.className='btn-secondary';
  editBtn.title='Edit chart configuration';
  
  const redrawBtn = document.createElement('button'); redrawBtn.textContent='Redraw';
  const pngBtn = document.createElement('button'); pngBtn.textContent='Download PNG';
  const addChartBtn = document.createElement('button'); addChartBtn.textContent = 'Add Chart';
  const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'Delete';

  controls.append(typeSel, topNInput, editBtn, redrawBtn, pngBtn, addChartBtn, deleteBtn);
  head.append(left, controls);
  // Auto redraw + auto-save on control changes
  typeSel.addEventListener('change', () => { draw(); debouncedAutoSave(); });
  topNInput.addEventListener('change', () => { draw(); debouncedAutoSave(); });

  addChartBtn.onclick = () => {
    const t = typeSel.value;
    const n = Math.max(3, Math.min(999, Number(topNInput.value) || 20));
    const parentCard = c.closest('.card');
    const chartsContainer = parentCard.querySelector('.chart-cards');
    const title = parentCard.querySelector('.card-title').textContent;
    renderChartCard(agg, chartsContainer, t, n, title.replace(/\s+/, '_'));
    showToast('New chart card added.', 'success');
    debouncedAutoSave();
  };

  deleteBtn.onclick = () => {
    const chartCard = c;
    const rec = chartRegistry.get(canvas);
    if (rec) {
      if (rec.ro) {
        try { rec.ro.disconnect(); } catch {}
      }
      if (rec.chart) {
        try { rec.chart.destroy(); } catch {}
      }
      chartRegistry.delete(canvas);
    }
    chartCard.remove();
    showToast('Chart deleted.', 'info');
    debouncedAutoSave();
  };
  c.appendChild(head);
  const box = document.createElement('div'); box.className='chart-box';
  const canvas = document.createElement('canvas'); box.appendChild(canvas); c.appendChild(box); chartsContainer.appendChild(c);
  function draw(){
    const topN = Number(topNInput.value)||20;
    const cfg = computeChartConfig(agg, typeSel.value, topN, { noAnimation });
    const isCircular = (cfg.type==='pie' || cfg.type==='doughnut' || cfg.type==='polarArea' || cfg.type==='radar');

    // Keep previously applied dims to detect changes
    const prevW = canvas.dataset.w || '';
    const prevH = canvas.dataset.h || '';

    // Completely reset all inline styles to avoid conflicts
    canvas.setAttribute('style', '');
    
    // Force container-based sizing first
    canvas.style.display = 'block';
    canvas.style.width = '100%';
    canvas.style.height = '100%';

    // Determine target size
    let shouldResize = false;

    // Let all charts use container sizing for responsive design
    shouldResize = (prevW || prevH); // trigger resize if we had custom sizing before
    
    // Clear any previous custom sizing
    delete canvas.dataset.w;
    delete canvas.dataset.h;

    ensureChart(canvas, cfg, shouldResize);
    if (!noAnimation) showToast('Chart redrawn.', 'info');
  }
  
  // Create edit panel (initially hidden)
  const editPanel = document.createElement('div');
  editPanel.className = 'edit-panel';
  editPanel.style.display = 'none';
  editPanel.style.padding = '12px';
  editPanel.style.background = '#f8f9fa';
  editPanel.style.border = '1px solid #e2e8f0';
  editPanel.style.borderRadius = '8px';
  editPanel.style.marginTop = '8px';
  
  // Extract current configuration
  const groupByCol = agg.header[0];
  const metricCol = agg.header[1] !== 'count' ? agg.header[1] : null;
  const aggFunction = agg.header[1] === 'count' ? 'count' : 
                     agg.header[1].includes('avg') ? 'avg' : 
                     agg.header[1].includes('sum') ? 'sum' : 'sum';
  
  // Detect date bucket from groupBy column
  let dateBucket = '';
  const bucketMatch = groupByCol.match(/\((day|week|month|quarter|year)\)/i);
  if (bucketMatch) {
    dateBucket = bucketMatch[1].toLowerCase();
  }
  const cleanGroupBy = groupByCol.replace(/\s*\((day|week|month|quarter|year)\)$/i, '');
  
  // Create edit controls
  editPanel.innerHTML = `
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; align-items: end;">
      <label>Group by:
        <select id="edit-groupby" style="width: 100%; margin-top: 4px;">
          ${PROFILE.columns.filter(c => ['string','date'].includes(c.type)).map(c => 
            `<option value="${c.name}" ${c.name === cleanGroupBy ? 'selected' : ''}>${c.name}</option>`
          ).join('')}
        </select>
      </label>
      <label>Date bucket:
        <select id="edit-bucket" style="width: 100%; margin-top: 4px;">
          <option value="">None</option>
          <option value="day" ${dateBucket === 'day' ? 'selected' : ''}>Day</option>
          <option value="week" ${dateBucket === 'week' ? 'selected' : ''}>Week</option>
          <option value="month" ${dateBucket === 'month' ? 'selected' : ''}>Month</option>
          <option value="quarter" ${dateBucket === 'quarter' ? 'selected' : ''}>Quarter</option>
          <option value="year" ${dateBucket === 'year' ? 'selected' : ''}>Year</option>
        </select>
      </label>
      <label>Metric:
        <select id="edit-metric" style="width: 100%; margin-top: 4px;">
          <option value="">Count records</option>
          ${PROFILE.columns.filter(c => c.type === 'number').map(c => 
            `<option value="${c.name}" ${c.name === metricCol ? 'selected' : ''}>${c.name}</option>`
          ).join('')}
        </select>
      </label>
      <label>Function:
        <select id="edit-function" style="width: 100%; margin-top: 4px;">
          <option value="sum" ${aggFunction === 'sum' || aggFunction === 'count' ? 'selected' : ''}>Sum (Default for ERP)</option>
          <option value="avg" ${aggFunction === 'avg' ? 'selected' : ''}>Average</option>
          <option value="min" ${aggFunction === 'min' ? 'selected' : ''}>Minimum</option>
          <option value="max" ${aggFunction === 'max' ? 'selected' : ''}>Maximum</option>
        </select>
      </label>
      <div style="display: flex; gap: 8px;">
        <button id="edit-apply" style="padding: 6px 12px; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer;">Apply</button>
        <button id="edit-cancel" style="padding: 6px 12px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
      </div>
    </div>
  `;
  
  c.appendChild(editPanel);
  
  // Add dynamic behavior to metric/function relationship
  const metricSelect = editPanel.querySelector('#edit-metric');
  const functionSelect = editPanel.querySelector('#edit-function');
  
  metricSelect.addEventListener('change', () => {
    if (!metricSelect.value) {
      // No metric selected - force count function
      functionSelect.value = 'count';
      functionSelect.disabled = true;
    } else {
      // Metric selected - enable all functions
      functionSelect.disabled = false;
      if (functionSelect.value === 'count') {
        functionSelect.value = 'sum'; // Default to sum when metric is selected
      }
    }
  });
  
  // Initialize function dropdown state
  if (!metricSelect.value) {
    functionSelect.value = 'count';
    functionSelect.disabled = true;
  }
  
  // Edit button functionality
  editBtn.onclick = () => {
    if (editPanel.style.display === 'none') {
      editPanel.style.display = 'block';
      editBtn.textContent = 'Cancel Edit';
    } else {
      editPanel.style.display = 'none';
      editBtn.textContent = 'Edit';
    }
  };
  
  // Apply changes functionality
  editPanel.querySelector('#edit-apply').onclick = () => {
    const newGroupBy = editPanel.querySelector('#edit-groupby').value;
    const newBucket = editPanel.querySelector('#edit-bucket').value;
    const newMetric = editPanel.querySelector('#edit-metric').value || null;
    const newFunction = editPanel.querySelector('#edit-function').value;

    // If no metric selected, force count
    const finalFunction = !newMetric ? 'count' : newFunction;

    // Recompute aggregate for this card using included rows
    const newAgg = groupAgg(getIncludedRows(), newGroupBy, newMetric, finalFunction, newBucket);

    // Update the current card's aggregate data (affects all charts in this card)
    agg.header = newAgg.header;
    agg.rows = newAgg.rows;

    // Update the header display for this chart card
    left.textContent = `Chart for: ${newAgg.header[1]} by ${newAgg.header[0]}`;

    // Find and update the associated table and persist job definition on the parent card
    const chartCard = c;
    const chartsContainer = chartCard.parentElement;
    const parentCard = chartsContainer.parentElement;

    if (parentCard) {
      // Persist job definition so snapshots capture this edit
      parentCard.dataset.groupBy = newGroupBy || '';
      parentCard.dataset.metric = newMetric || '';
      parentCard.dataset.agg = finalFunction || '';
      parentCard.dataset.dateBucket = newBucket || '';

      // Update card subheader
      const cardSub = parentCard.querySelector('.card-sub');
      if (cardSub) {
        cardSub.textContent = `${newAgg.rows.length} groups Â· ${newAgg.header[1]}`;
      }

      // Re-render table
      const tableBox = parentCard.querySelector('.table-wrap');
      if (tableBox) {
        renderAggTable(agg, tableBox, 20);
      }
    }

    // Redraw the chart with new data
    draw();

    // Hide edit panel
    editPanel.style.display = 'none';
    editBtn.textContent = 'Edit';
    showToast('Aggregate updated for this card and will be saved in history.', 'success');
    debouncedAutoSave();
  };
  
  // Cancel edit functionality
  editPanel.querySelector('#edit-cancel').onclick = () => {
    editPanel.style.display = 'none';
    editBtn.textContent = 'Edit';
    showToast('Aggregate table updated.', 'success');
  };
  
  redrawBtn.onclick = () => { draw(); debouncedAutoSave(); }; pngBtn.onclick = ()=>{ const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download = `${titleForFile}.png`; a.click(); showToast('Chart downloaded as PNG.', 'success'); };
  draw();
  return c;
}

/* ========= aggregate table (sortable + download) ========= */
function renderAggTable(agg, container, previewN=10, showMissing = false){
  container.innerHTML = '';
  
  // State variables for this table
  let currentPage = 1;
  let rowsPerPage = previewN;
  let searchQuery = '';
  let sortIdx = /\((day|week|month|quarter|year)\)/i.test(agg.header[0]||'') ? 0 : 1;
  let sortDir = sortIdx===0 ? 'asc' : 'desc';
  let filteredRows = [...agg.rows];
  
  // Create table elements
  const tableControls = document.createElement('div');
  tableControls.className = 'table-controls';
  
  const tableWrap = document.createElement('div');
  tableWrap.className = 'data-table-wrap';
  
  const table = document.createElement('table');
  const thead = document.createElement('thead');
  const tbody = document.createElement('tbody');
  const tfoot = document.createElement('tfoot');
  
  // Create search input
  const searchLabel = document.createElement('label');
  searchLabel.textContent = 'Search: ';
  const searchInput = document.createElement('input');
  searchInput.type = 'text';
  searchInput.placeholder = 'Type to filter...';
  searchInput.style.minWidth = '150px';
  searchLabel.appendChild(searchInput);
  
  // Create rows per page selector
  const rowsPerPageLabel = document.createElement('label');
  rowsPerPageLabel.textContent = 'Rows per page: ';
  const rowsPerPageSelect = document.createElement('select');
  rowsPerPageSelect.innerHTML = `
    <option value="10">10</option>
    <option value="25">25</option>
    <option value="50">50</option>
    <option value="100">100</option>
    <option value="0">All</option>
  `;
  rowsPerPageSelect.value = String(previewN);
  rowsPerPageLabel.appendChild(rowsPerPageSelect);
  
  // Create pager
  const pager = document.createElement('div');
  pager.className = 'pager';
  const prevButton = document.createElement('button');
  prevButton.textContent = 'Prev';
  const pageInfo = document.createElement('span');
  pageInfo.className = 'count';
  pageInfo.textContent = 'Page 1 / 1';
  const nextButton = document.createElement('button');
  nextButton.textContent = 'Next';
  pager.append(prevButton, pageInfo, nextButton);
  
  tableControls.append(searchLabel, rowsPerPageLabel, pager);
  container.appendChild(tableControls);
  
  // Create table header
  const trh = document.createElement('tr');
  const headerSortSpans = [];
  agg.header.forEach((h, i) => {
    const th = document.createElement('th');
    th.textContent = h;
    const s = document.createElement('span');
    s.className = 'sort';
    s.textContent = '';
    th.appendChild(s);
    headerSortSpans[i] = s;
    th.style.cursor = 'pointer';
    th.addEventListener('click', () => {
      if (sortIdx === i) {
        sortDir = (sortDir === 'asc' ? 'desc' : 'asc');
      } else {
        sortIdx = i;
        sortDir = i === 0 ? 'asc' : 'desc';
      }
      currentPage = 1;
      updateTable();
    });
    trh.appendChild(th);
  });
  thead.appendChild(trh);
  table.appendChild(thead);
  table.appendChild(tbody);
  table.appendChild(tfoot);
  tableWrap.appendChild(table);
  container.appendChild(tableWrap);
  
  // Create footer with download button
  const foot = document.createElement('div');
  foot.className = 'card-foot';
  const dl = document.createElement('button');
  dl.textContent = 'Download CSV';
  dl.onclick = () => {
    const csv = [agg.header, ...agg.rows].map(r => r.map(s => {
      const z = String(s ?? '');
      return /[",\n]/.test(z) ? `"${z.replace(/"/g, '""')}"` : z;
    }).join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `${(agg.header[1] + ' by ' + agg.header[0]).replace(/\s+/g, '_')}.csv`;
    a.click();
    URL.revokeObjectURL(a.href);
    showToast('Aggregate data downloaded as CSV.', 'success');
  };
  foot.appendChild(dl);
  container.appendChild(foot);
  
  // Function to highlight search terms in text
  function highlightText(text, query) {
    if (!query || !query.trim()) return text;
    // Escape HTML in the text first to prevent XSS
    const safeText = String(text).replace(/[&<>"']/g, function(m) {
      return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m];
    });
    const escapedQuery = query.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(${escapedQuery})`, 'gi');
    return safeText.replace(regex, '<mark>$1</mark>');
  }
  
  // Filter rows based on search query
  function filterRows() {
    const query = searchQuery.toLowerCase().trim();
    if (!query) {
      filteredRows = [...agg.rows];
      return;
    }
    
    filteredRows = agg.rows.filter(row => {
      return row.some(cell => String(cell).toLowerCase().includes(query));
    });
  }
  
  // Sort rows
  function sortRows() {
    filteredRows.sort((a, b) => {
      if (sortIdx === 1) {
        const av = Number(a[1]) || 0;
        const bv = Number(b[1]) || 0;
        return sortDir === 'asc' ? (av - bv) : (bv - av);
      } else {
        const as = String(a[0] ?? '').toLowerCase();
        const bs = String(b[0] ?? '').toLowerCase();
        const cmp = as < bs ? -1 : as > bs ? 1 : 0;
        return sortDir === 'asc' ? cmp : -cmp;
      }
    });
  }
  
  // Render table body
  function renderTableBody() {
    tbody.innerHTML = '';
    
    const totalFiltered = filteredRows.length;
    const totalPages = rowsPerPage === 0 ? 1 : Math.ceil(totalFiltered / rowsPerPage);
    
    // Adjust current page if it's out of bounds
    if (currentPage > totalPages && totalPages > 0) {
      currentPage = totalPages;
    }
    
    // Calculate start and end indices
    let start, end;
    if (rowsPerPage === 0) {
      // Show all rows
      start = 0;
      end = totalFiltered;
    } else {
      // Show paginated rows
      start = (currentPage - 1) * rowsPerPage;
      end = Math.min(start + rowsPerPage, totalFiltered);
    }
    
    // Get rows to display
    const displayRows = filteredRows.slice(start, end);
    
    // Render rows with highlighted search terms
    displayRows.forEach(r => {
      const tr = document.createElement('tr');
      const td0 = document.createElement('td');
      td0.innerHTML = highlightText(String(r[0]), searchQuery);
      const td1 = document.createElement('td');
      const numValue = nice(Number(r[1]) || 0);
      // Apply highlighting to numeric values too
      if (searchQuery.trim()) {
        td1.innerHTML = highlightText(String(numValue), searchQuery);
      } else {
        td1.textContent = numValue;
      }
      tr.append(td0, td1);
      tbody.appendChild(tr);
    });
    
    // Update page info
    if (totalFiltered === 0) {
      pageInfo.textContent = 'No rows found';
    } else if (rowsPerPage === 0) {
      pageInfo.textContent = `Showing all ${totalFiltered} rows`;
    } else {
      pageInfo.textContent = `Page ${currentPage} / ${totalPages} (${totalFiltered} total)`;
    }
    
    // Update button states
    prevButton.disabled = currentPage <= 1;
    nextButton.disabled = currentPage >= totalPages;
  }
  
  // Render table footer with sums
  function renderTableFooter() {
    tfoot.innerHTML = '';
    const tr1 = document.createElement('tr');
    const tr2 = document.createElement('tr');
    const tr3 = document.createElement('tr');
    const tr4 = document.createElement('tr');
    const tr5 = document.createElement('tr');
    const tr6 = document.createElement('tr'); // New row for removed groups
    const tr7 = document.createElement('tr'); // New row for raw data sum

    // First cell labels
    const labelCell1 = document.createElement('td'); labelCell1.textContent = 'Î£ visible (table filter)'; labelCell1.className = 'footer-label';
    const labelCell2 = document.createElement('td'); labelCell2.textContent = 'Î£ table (post-minGroupShare)'; labelCell2.className = 'footer-label';
    const labelCell3 = document.createElement('td'); labelCell3.textContent = 'Î£ total (pre-filter)'; labelCell3.className = 'footer-label';
    const labelCell4 = document.createElement('td'); labelCell4.className = 'footer-label';
    const removedCount = (agg.groupsBeforeFilter || 0) - agg.rows.length;
    if (removedCount > 0) {
      labelCell4.innerHTML = `Removed by minGroupShare <a href="#" class="view-removed-details">(View Details)</a>`;
      labelCell4.querySelector('.view-removed-details').onclick = (e) => {
        e.preventDefault();
        const modal = $('#removedRowsModal');
        const tbody = modal.querySelector('#removedRowsTable tbody');
        const thead = modal.querySelector('#removedRowsTable thead');
        modal.querySelector('.modal-head h3').textContent = 'Rows Removed by minGroupShare';
        tbody.innerHTML = '';
        thead.innerHTML = `<tr><th>${agg.header[0]}</th><th>${agg.header[1]}</th></tr>`;
        agg.removedRows.forEach(r => {
          const tr = document.createElement('tr');
          const tdKey = document.createElement('td');
          tdKey.textContent = String(r[0]);
          const tdVal = document.createElement('td');
          tdVal.textContent = formatNumberFull(Number(r[1] || 0));
          tr.append(tdKey, tdVal);
          tbody.appendChild(tr);
        });
        modal.classList.add('open');
      };
    } else {
      labelCell4.textContent = 'Removed by minGroupShare';
    }
    const labelCell5 = document.createElement('td'); labelCell5.className = 'footer-label';
    const statusText = showMissing ? '(Included)' : '(Excluded)';

    if (agg.missingRows && agg.missingRows.length > 0) {
      labelCell5.innerHTML = `Missing (group key) ${statusText} <a href="#" class="view-missing-details">(View Details)</a>`;
      labelCell5.querySelector('.view-missing-details').onclick = (e) => {
        e.preventDefault();
        const modal = $('#removedRowsModal');
        const tbody = modal.querySelector('#removedRowsTable tbody');
        const thead = modal.querySelector('#removedRowsTable thead');
        const modalTitle = modal.querySelector('.modal-head h3');
        
        modalTitle.textContent = `Rows with Missing Group Key (${agg.header[0]})`;
        tbody.innerHTML = '';
        
        thead.innerHTML = `<tr>${DATA_COLUMNS.map(h => `<th>${h}</th>`).join('')}</tr>`;

        agg.missingRows.forEach(r => {
          const tr = document.createElement('tr');
          DATA_COLUMNS.forEach(colName => {
            const td = document.createElement('td');
            td.textContent = r[colName] ?? '';
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        modal.classList.add('open');
      };
    } else {
      labelCell5.textContent = `Missing (group key) ${statusText}`;
    }
    const labelCell6 = document.createElement('td'); labelCell6.textContent = 'Î£ Total Record'; labelCell6.className = 'footer-label';
    const labelCell7 = document.createElement('td'); labelCell7.textContent = 'Raw Data Sum (pre-aggregation)'; labelCell7.className = 'footer-label';

    // Value cells for numeric column (index 1)
    const val1 = document.createElement('td');
    const val2 = document.createElement('td');
    const val3 = document.createElement('td');
    const val4 = document.createElement('td');
    const val5 = document.createElement('td');
    const val6 = document.createElement('td');
    const val7 = document.createElement('td');

    // Compute sums
    const visibleSum = filteredRows.reduce((a, r) => a + (Number(r[1]) || 0), 0);
    const sumAggRows = agg.rows.reduce((a, r) => a + (Number(r[1]) || 0), 0);
    const removedSum = (agg.totalSum || 0) - sumAggRows;

    val1.textContent = formatNumberFull(visibleSum);
    val2.textContent = formatNumberFull(sumAggRows);
    val3.textContent = formatNumberFull(Number(agg.totalSum || 0));
    val4.textContent = `${formatNumberFull(removedSum)} (${removedCount} groups)`;
    val5.textContent = formatNumberFull(Number(agg.missingSum || 0));
    val6.textContent = agg.rawRowsCount ? agg.rawRowsCount.toLocaleString() : '0';
    val7.textContent = formatNumberFull(Number(agg.rawDataSum || 0));

    // Build rows
    tr1.appendChild(labelCell1);
    tr1.appendChild(val1);
    tr2.appendChild(labelCell2);
    tr2.appendChild(val2);
    tr3.appendChild(labelCell3);
    tr3.appendChild(val3);
    tr4.appendChild(labelCell4);
    tr4.appendChild(val4);
    tr5.appendChild(labelCell5);
    tr5.appendChild(val5);
    tr6.appendChild(labelCell6);
    tr6.appendChild(val6);
    tr7.appendChild(labelCell7);
    tr7.appendChild(val7);

    tfoot.appendChild(tr1);
    tfoot.appendChild(tr2);
    tfoot.appendChild(tr3);
    tfoot.appendChild(tr4);
    tfoot.appendChild(tr5);
    tfoot.appendChild(tr6);
    tfoot.appendChild(tr7);
  }
  
  // Update entire table
  function updateTable() {
    filterRows();
    sortRows();
    renderTableBody();
    renderTableFooter();
  }
  
  // Event listeners
  searchInput.addEventListener('input', debounce(() => {
    searchQuery = searchInput.value;
    currentPage = 1;
    updateTable();
  }, 300));
  
  rowsPerPageSelect.addEventListener('change', () => {
    const val = rowsPerPageSelect.value;
    rowsPerPage = val === '0' ? 0 : Number(val);
    currentPage = 1;
    updateTable();
  });
  
  prevButton.addEventListener('click', () => {
    if (currentPage > 1) {
      currentPage--;
      updateTable();
    }
  });
  
  nextButton.addEventListener('click', () => {
    const totalPages = rowsPerPage === 0 ? 1 : Math.ceil(filteredRows.length / rowsPerPage);
    if (currentPage < totalPages) {
      currentPage++;
      updateTable();
    }
  });
  
  // Initial render
  updateTable();
}

/* ========= Manual Mode: Role Editor + Add Aggregate ========= */
function openRoleEditor(){
  const modal = $('#roleModal'); const tb = $('#roleTBody'); tb.innerHTML='';
  PROFILE.columns.forEach(c=>{
    const tr=document.createElement('tr');
    const roleAuto = inferRole(c, PROFILE, ROWS).role;
    const current = MANUAL_ROLES[c.name] || roleAuto;
    const tdName = document.createElement('td'); tdName.textContent = c.name;
    const tdType = document.createElement('td'); tdType.textContent = c.type;
    const tdUniq = document.createElement('td'); tdUniq.textContent = c.unique;
    const tdRole = document.createElement('td');
    const sel = document.createElement('select'); sel.setAttribute('data-col', c.name);
    ['dimension','metric','date','id','ignore'].forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=v; sel.appendChild(o); });
    sel.value = current.replace('metric:strong','metric'); tdRole.appendChild(sel);
    const tdSample = document.createElement('td'); tdSample.className='muted small'; tdSample.textContent = (c.samples||[]).join(' | ');
    tr.append(tdName, tdType, tdUniq, tdRole, tdSample); tb.appendChild(tr);
  });
  modal.classList.add('open');
  modal.focus();
}
$('#closeRoleModal').onclick = ()=> $('#roleModal').classList.remove('open');
$('#saveRoles').onclick = ()=>{
  MANUAL_ROLES = {};
  $('#roleTBody').querySelectorAll('select').forEach(sel=>{ MANUAL_ROLES[ sel.getAttribute('data-col') ] = sel.value; });
  $('#roleModal').classList.remove('open');
  renderAggregates();
  showToast('Column roles saved.', 'success');
  debouncedAutoSave();
};

function planFromManualRoles(profile){
  const getCols = (role)=> profile.columns.filter(c => (MANUAL_ROLES[c.name]||'')===role);
  const dims = getCols('dimension');
  const dates = getCols('date');
  const metrics = getCols('metric');
  const primary = metrics[0] || pickPrimaryMetric(profile, ROWS);
  const jobs=[], charts=[];
  if (dates.length && primary){
    jobs.push({ groupBy: dates[0].name, metric: primary.name, agg:'sum', dateBucket:autoBucket(ROWS, dates[0].name) });
    charts.push({ useJob: jobs.length-1, preferredType:'line', title:`${primary.name} over ${dates[0].name}` });
  }
  dims.slice(0,3).forEach(d=>{
    if (primary){
      jobs.push({ groupBy:d.name, metric:primary.name, agg:'sum' });
      charts.push({ useJob: jobs.length-1, preferredType:d.unique<=8?'pie':'bar', title:`${primary.name} by ${d.name}` });
      jobs.push({ groupBy:d.name, metric:primary.name, agg:'avg' });
      charts.push({ useJob: jobs.length-1, preferredType:'hbar', title:`avg ${primary.name} by ${d.name}` });
    }
    // For ERP: Skip count, focus only on sum-based metrics
    if (!primary) {
      // If no primary metric, still create sum aggregation but show warning
      jobs.push({ groupBy:d.name, metric:null, agg:'sum' });
      charts.push({ useJob: jobs.length-1, preferredType:d.unique<=8?'pie':'bar', title:`sum by ${d.name}` });
    }
  });
  // Apply canonical deduplication before returning
  const deduplicatedJobs = deduplicateJobs(jobs);
  return { jobs: deduplicatedJobs.slice(0,10), charts };
}

function openAddAgg(){
  const modal = $('#aggModal');
  const gb = $('#aggGroupBy'), mt = $('#aggMetric');
  const bucket = $('#aggBucket'); gb.innerHTML=''; mt.innerHTML=''; bucket.value='';
  const dims = MODE==='manual'
    ? PROFILE.columns.filter(c => (MANUAL_ROLES[c.name]||'')==='dimension' || (MANUAL_ROLES[c.name]||'')==='date')
    : PROFILE.columns.filter(c => ['string','date'].includes(c.type));
  const nums = MODE==='manual'
    ? PROFILE.columns.filter(c => (MANUAL_ROLES[c.name]||'')==='metric')
    : PROFILE.columns.filter(c => c.type==='number');
  dims.forEach(c=>{ const o=document.createElement('option'); o.value=c.name; o.textContent=c.name; gb.appendChild(o); });
  nums.forEach(c=>{ const o=document.createElement('option'); o.value=c.name; o.textContent=c.name; mt.appendChild(o); });
  modal.classList.add('open');
}
$('#closeAggModal').onclick = ()=> $('#aggModal').classList.remove('open');
$('#addAggConfirm').onclick = ()=>{
  const groupBy = $('#aggGroupBy').value;
  const metric  = $('#aggMetric').value || null;
  const agg     = $('#aggFunc').value;
  const chart   = $('#aggChart').value;
  const topN    = Math.max(3, Math.min(999, Number($('#aggTopN').value)||20));
  const dateBucket = $('#aggBucket').value || '';
  MANUAL_JOBS.push({ groupBy, metric, agg, chart, topN, dateBucket });
  $('#aggModal').classList.remove('open');
  renderAggregates();
  showToast('New aggregate added.', 'success');
  debouncedAutoSave();
};

/* ========= UI glue ========= */
$('#loadBtn').onclick = async ()=>{
  sessionStorage.setItem('isNewFileLoad', 'true');
  const f=$('#file').files[0]; if(!f) return showToast('Choose a CSV first.', 'error');
  $('#meta').textContent='Parsingâ€¦';
  try{
    const choice=$('#delimiter').value, header=$('#hasHeader').checked;
    const {data, meta}=await parseCSV(f, choice, header);
    if(!data.length) throw new Error('No rows detected (check delimiter/header).');
    ROWS=data; DATA_COLUMNS = Object.keys(ROWS[0] || {});
    const dateFormat = $('#dateFormat').value;
    PROFILE=profile(ROWS, dateFormat); renderProfile(PROFILE, LAST_PARSE_META);

    // Coerce numeric columns into numbers to avoid leftover leading-apostrophes in strings
    if (PROFILE && PROFILE.columns) {
      const numericCols = PROFILE.columns.filter(c => c.type === 'number').map(c => c.name);
      if (numericCols.length) {
        for (const r of ROWS) {
          for (const col of numericCols) {
            const cleaned = toNum(r[col]);
            // Only coerce when parsed is finite AND the original contains at least one digit
            if (Number.isFinite(cleaned) && /[0-9]/.test(String(r[col]))) {
              r[col] = cleaned;
            }
          }
        }
      }
    }
    $('#meta').textContent=`Loaded ${PROFILE.rowCount.toLocaleString()} rows, ${PROFILE.columns.length} columns. (delimiter="${meta.delimiter}")`;
    const resultsEl = $('#results');
    if (resultsEl) {
        resultsEl.innerHTML = '';
    }
    
    // Initialize row inclusion for manual file loading too
    initializeRowInclusion();
    buildRawHeader(DATA_COLUMNS);
    QUERY = ''; $('#searchInput').value='';
    SORT = { col:null, dir:'asc' };
    RPP = Number($('#rowsPerPage').value)||25; PAGE=1;
    applyFilter(); renderRawBody();
    MANUAL_ROLES = {}; MANUAL_JOBS = [];
    $('#mode').value='auto'; switchMode('auto');
    loadState(); // restore per-header state if available
    WorkflowManager.reset(MODE); // Reset AI todo list on new load
    showToast('CSV data loaded successfully.', 'success');

    // Auto-save the initial load as a new history item
    await saveCurrentStateToHistory(f.name, true); // Pass true to force new entry

    // Enable the update and save as new buttons
    $('#updateReportBtn').disabled = false;
    $('#saveAsNewBtn').disabled = false;
    
    // Auto-render aggregates if in auto mode (same logic as message handler)
    if ($('#mode').value === 'auto') {
      console.log('ğŸ¯ Auto-rendering aggregates after manual CSV load...');
      renderAggregates();
    }

  }catch(e){ console.error(e); showToast('Parse error: '+(e?.message||e), 'error'); $('#meta').textContent='Parse failed.'; }
};

$('#fileSelectBtn').onclick = () => $('#file').click();
$('#file').onchange = () => $('#loadBtn').click();

function switchMode(val){
  MODE = val;
  const manual = MODE==='manual';
  $('#editRolesBtn').style.display = manual ? '' : 'none';
  $('#addAggBtn').style.display   = manual ? '' : 'none';
  $('#clearManualBtn').style.display = manual ? '' : 'none';
  $('#recalcBtn').style.display = manual ? '' : 'none';
}
$('#mode').addEventListener('change', e=>{ switchMode(e.target.value); renderAggregates(); });
$('#dateFormat').addEventListener('change', ()=>{
  if (ROWS) {
    const dateFormat = $('#dateFormat').value;
    PROFILE = profile(ROWS, dateFormat);
    renderProfile(PROFILE, LAST_PARSE_META);
    renderAggregates();
    showToast(`Date format changed to ${dateFormat}. Re-profiling data.`, 'info');
    debouncedAutoSave();
  }
});
$('#autoExclude').addEventListener('change', e => {
  AUTO_EXCLUDE = e.target.checked;
  if (ROWS) {
    initializeRowInclusion();
    renderRawBody();
    // Re-render aggregates as the included rows have changed
    renderAggregates();
  }
  showToast(`Auto-exclude ${AUTO_EXCLUDE ? 'enabled' : 'disabled'}.`, 'info');
  debouncedAutoSave();
});
$('#editRolesBtn').onclick = openRoleEditor;
$('#addAggBtn').onclick = openAddAgg;
$('#clearManualBtn').onclick = ()=>{ MANUAL_ROLES={}; MANUAL_JOBS=[]; renderAggregates(); showToast('Manual overrides cleared.', 'info'); debouncedAutoSave(); };
$('#recalcBtn').onclick = ()=>{ renderAggregates(); showToast('Recalculated with current roles', 'success'); debouncedAutoSave(); };

$('#searchInput').addEventListener('input', onSearch);
$('#rowsPerPage').addEventListener('change', ()=>{ RPP = Number($('#rowsPerPage').value)||25; PAGE=1; renderRawBody(); });
$('#prevPage').addEventListener('click', ()=>{ if(PAGE>1){ PAGE--; renderRawBody(); } });
$('#nextPage').addEventListener('click', ()=>{ const pages=Math.max(1, Math.ceil(FILTERED_ROWS.length / RPP)); if(PAGE<pages){ PAGE++; renderRawBody(); } });
$('#resetExclusion').addEventListener('click', () => {
  if (ROWS) {
    initializeRowInclusion();
    renderRawBody();
    renderAggregates();
  }
});
$('#downloadFiltered').addEventListener('click', ()=>{
  if (!FILTERED_ROWS?.length) return;
  const esc = s => { const str = String(s ?? ''); return /[",\n]/.test(str) ? `"${str.replace(/"/g,'""')}"` : str; };
  const header = DATA_COLUMNS.map(esc).join(',');
  const sorted = sortRows(FILTERED_ROWS);
  const body = sorted.map(r => DATA_COLUMNS.map(c => esc(r[c])).join(',')).join('\n');
  const blob = new Blob([header+'\n'+body], {type:'text/csv;charset=utf-8'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = 'filtered_rows.csv'; a.click(); URL.revokeObjectURL(a.href);
  showToast('Filtered CSV downloaded', 'success');
});

$('#autoBtn').onclick = () => renderAggregates();

async function workerAggregateWithFallback(rows, profile, plan, timeoutMs = 15000) {
  // Fallback function using existing main-thread logic
  const localAggregate = () => {
    console.log('Executing local fallback for aggregation.');
    return plan.jobs.map(j => groupAgg(rows, j.groupBy, j.metric, j.agg, j.dateBucket || ''));
  };

  if (typeof Worker === 'undefined') {
    console.warn('Worker not supported, falling back to main thread.');
    return localAggregate();
  }

  let w;
  try {
    w = new Worker('parser.worker.js');
  } catch (e) {
    console.warn('Worker creation failed:', e);
    showToast('Could not start worker, falling back to main thread.', 'info');
    return localAggregate();
  }

  return new Promise((resolve) => {
    const timer = setTimeout(() => {
      try { w.terminate(); } catch {}
      console.warn('Worker timed out, falling back to main thread.');
      showToast('Worker timed out â€” falling back to main thread.', 'info');
      resolve(localAggregate());
    }, timeoutMs);

    w.onmessage = (e) => {
      clearTimeout(timer);
      if (e.data && !e.data.error) {
        resolve(e.data.aggregated);
      } else {
        console.warn('Worker returned an error, falling back:', e.data?.message || 'worker error');
        showToast('Worker failed â€” falling back to main thread.', 'info');
        resolve(localAggregate());
      }
      try { w.terminate(); } catch {}
    };

    w.onerror = (err) => {
      clearTimeout(timer);
      console.warn('Worker onerror, falling back:', err?.message || 'worker error');
      showToast('Worker failed â€” falling back to main thread.', 'info');
      resolve(localAggregate());
      try { w.terminate(); } catch {}
    };

    // Post message to the worker
    w.postMessage({
      action: 'aggregate',
      rows: rows,
      profile: profile,
      plan: plan,
      config: {
        showMissing: false, // Worker will not handle missing data inclusion initially
        minGroupShare: 0 // Default to 0; per-card sliders will re-agg on main thread
      }
    });
  });
}

function renderExplanationCard(parentCard, title, contentHTML) {
  const explanationContainer = document.createElement('div');
  explanationContainer.className = 'ai-explanation';
  explanationContainer.style.borderTop = '1px solid #eee';

  const head = document.createElement('div');
  head.className = 'card-head';
  
  const h = document.createElement('h4');
  h.className = 'card-title';
  h.textContent = title;
  
  const regenerateBtn = document.createElement('button');
  regenerateBtn.textContent = 'Regenerate';
  regenerateBtn.className = 'regenerate-btn';

  head.appendChild(h);
  head.appendChild(regenerateBtn);
  explanationContainer.appendChild(head);

  const contentEl = document.createElement('div');
  contentEl.className = 'ai-explanation-content';
  contentEl.style.padding = '16px';
  contentEl.innerHTML = contentHTML;
  explanationContainer.appendChild(contentEl);

  const cardFoot = parentCard.querySelector('.card-foot');
  if (cardFoot) {
    cardFoot.insertAdjacentElement('afterend', explanationContainer);
  } else {
    parentCard.appendChild(explanationContainer);
  }
  
  return { explanationContainer, contentEl, regenerateBtn };
}

async function generateExplanation(agg, job, parentCard) {
    const apiKey = localStorage.getItem('gemini_api_key');
    const model = localStorage.getItem('gemini_model') || 'gemini-2.5-flash';

    // Do not render anything if the API key is missing or empty
    if (!apiKey || apiKey.trim() === '') {
      const existingExplanation = parentCard.querySelector('.ai-explanation');
      if (existingExplanation) {
        existingExplanation.style.display = 'none';
      }
      return;
    }
 
    // Render/replace explanation container first
    const existingExplanation = parentCard.querySelector('.ai-explanation');
    if (existingExplanation) {
      existingExplanation.remove();
    }
 
    const title = `AI Explanation for ${agg.header[1]} by ${agg.header[0]}`;
    const loaderHTML = '<p>Generating explanation...</p>';
    const { contentEl, regenerateBtn } = renderExplanationCard(parentCard, title, loaderHTML);
 
    regenerateBtn.onclick = () => {
      contentEl.innerHTML = loaderHTML;
      regenerateBtn.disabled = true;
      generateExplanation(agg, job, parentCard);
    };
 
    const timingLabel = `generateExplanation:${parentCard.dataset.canonicalKey || Math.random().toString(36).slice(2)}:${Date.now()}`;
    console.time(timingLabel);
    console.log(`â± generateExplanation start: ${timingLabel}`);
    try {
      const context = {
        agg,
        job,
        profile: PROFILE,
        rows: ROWS.slice(0, 5)
      };
 
      const prompt = `
        You are a data analyst. Explain the following data aggregation.
        Provide a short explanation (2-4 paragraphs) describing what the aggregate shows, notable anomalies, and suggested follow-up analyses.
 
        Context:
        ${JSON.stringify(context, null, 2)}
      `;
 
      const explanation = await fetchWithRetry(apiKey, model, prompt, showToast);
      contentEl.innerHTML = marked.parse(explanation);
      parentCard.dataset.explanationMarkdown = explanation; // Store raw explanation
 
      // Save explanation to history
      if (window.currentHistoryId) {
        const historyItem = await Store.getHistory(window.currentHistoryId);
        if (historyItem && historyItem.uiSnapshot && historyItem.uiSnapshot.charts) {
          const chartSnapshot = historyItem.uiSnapshot.charts.find(c =>
            c.cardJobKey &&
            c.cardJobKey.groupBy === job.groupBy &&
            c.cardJobKey.metric === job.metric &&
            c.cardJobKey.agg === job.agg &&
            c.cardJobKey.dateBucket === job.dateBucket
          );
          if (chartSnapshot) {
            chartSnapshot.explanation = explanation;
            await Store.updateHistory(window.currentHistoryId, { uiSnapshot: historyItem.uiSnapshot });
          }
        }
      }
      console.timeEnd(timingLabel);
      console.log(`â± generateExplanation end: ${timingLabel}`);
      
      // Auto-save after explanation is successfully generated
      console.log(`ğŸ”„ Triggering auto-save after explanation completion...`);
      debouncedAutoSave();
    } catch (error) {
      console.timeEnd(timingLabel);
      console.error(`â± generateExplanation error (${timingLabel}):`, error);
      contentEl.innerHTML = `<p style="color: red;">Error generating explanation: ${error.message}</p>`;
      showToast(`AI Error: ${error.message}`, 'error');
    } finally {
      regenerateBtn.disabled = false;
    }
  }

async function buildAggCard(job, cardState = {}, sessionId = null, options = {}) {
    const {
        showMissing = false,
        filterValue = 0,
        filterMode = 'share',
        charts = [{ type: 'auto', topN: 20 }],
        explanation = null,
        noAnimation = false // Pass noAnimation through cardState
    } = cardState;
    const { skipExplanation = false } = options;

    // Generate canonical key for deduplication and state management
    const canonicalKey = canonicalJobKey(job);
    console.log('[Debug] buildAggCard: Building card for job:', { job, canonicalKey });
    
    // Session validation - prevent stale results
    if (sessionId && window.currentAggregationSession && window.currentAggregationSession !== sessionId) {
        console.log(`â¹ï¸ Skipping buildAggCard due to session mismatch: current=${window.currentAggregationSession}, expected=${sessionId}`);
        const dummyCard = document.createElement('div');
        dummyCard.style.display = 'none';
        return dummyCard; // Return invisible dummy to prevent breaking code flow
    }

    const card = document.createElement('div');
    card.className = 'card';
    card.style.gridRowEnd = 'span 35'; // Pre-allocate space to prevent overlap

    // Persist job definition, canonical key, and state on the card
    card.dataset.groupBy = job.groupBy || '';
    card.dataset.metric = job.metric || '';
    card.dataset.agg = job.agg || '';
    card.dataset.dateBucket = job.dateBucket || '';
    card.dataset.showMissing = String(showMissing);
    card.dataset.canonicalKey = canonicalKey;
    if (sessionId) card.dataset.sessionId = sessionId;

    const title = `${job.agg}(${job.metric || ''}) by ${job.groupBy}`;
    const head = document.createElement('div');
    head.className = 'card-head';
    const left = document.createElement('div');
    const h = document.createElement('h4');
    h.className = 'card-title';
    h.textContent = title;
    const sub = document.createElement('div');
    sub.className = 'card-sub';
    left.append(h, sub);

    const toggleBtn = document.createElement('button');
    toggleBtn.className = 'card-toggle';
    toggleBtn.innerHTML = '<span class="chev"></span>';
    toggleBtn.setAttribute('aria-label', 'Toggle card content');

    head.append(left, toggleBtn);
    card.appendChild(head);

    const cardContent = document.createElement('div');
    cardContent.className = 'card-content';
    card.appendChild(cardContent);

    const controls = document.createElement('div');
    controls.className = 'card-controls';
    cardContent.appendChild(controls);

    // Add filter controls
    const filterLabel = document.createElement('label');
    filterLabel.textContent = 'Min Group Share/Value: ';
    const filterInput = document.createElement('input');
    filterInput.type = 'number';
    filterInput.className = 'filter-input';
    filterInput.value = String(filterValue);
    filterInput.min = '0';
    filterInput.step = '0.01';
    filterInput.style.width = '80px';
    
    const filterModeSelect = document.createElement('select');
    filterModeSelect.className = 'filter-mode-select';
    filterModeSelect.innerHTML = `
        <option value="share" ${filterMode === 'share' ? 'selected' : ''}>% Share</option>
        <option value="value" ${filterMode === 'value' ? 'selected' : ''}>Absolute Value</option>
    `;

    controls.append(filterLabel, filterInput, filterModeSelect);
    
    // Add per-card missing data toggle control (default Off)
    const missingToggleWrap = document.createElement('label');
    missingToggleWrap.style.marginRight = '12px';
    const missingToggle = document.createElement('input');
    missingToggle.type = 'checkbox';
    missingToggle.checked = !!showMissing;
    missingToggle.style.marginRight = '6px';
    missingToggle.addEventListener('change', () => {
        reRenderCard(!!missingToggle.checked);
        debouncedAutoSave();
    });
    missingToggleWrap.appendChild(missingToggle);
    missingToggleWrap.appendChild(document.createTextNode("Include '(Missing)' group"));
    // Place toggle before other controls
    controls.prepend(missingToggleWrap);

    const applyFilterOnChange = () => {
        reRenderCard(card.dataset.showMissing === 'true');
        debouncedAutoSave();
    };

    filterInput.addEventListener('change', applyFilterOnChange);
    filterInput.addEventListener('input', debounce(applyFilterOnChange, 300));
    filterModeSelect.addEventListener('change', applyFilterOnChange);

    const chartsContainer = document.createElement('div');
    chartsContainer.className = 'chart-cards';
    cardContent.appendChild(chartsContainer);

    const tableBox = document.createElement('div');
    tableBox.className = 'table-wrap';
    cardContent.appendChild(tableBox);

    toggleBtn.addEventListener('click', () => {
        card.classList.toggle('is-collapsed');
        
        // Wait for the CSS transition to finish before applying masonry layout
        card.querySelector('.card-content').addEventListener('transitionend', () => {
            applyMasonryLayout();
        }, { once: true });

        // Fallback in case transitionend doesn't fire
        setTimeout(applyMasonryLayout, 550);
    });

    function reRenderCard(newShowMissing) {
        const currentFilterValue = Number(card.querySelector('.filter-input')?.value || 0);
        const currentFilterMode = card.querySelector('.filter-mode-select')?.value || 'share';

        const newAgg = groupAgg(getIncludedRows(), job.groupBy, job.metric, job.agg, job.dateBucket || '', {
            mode: currentFilterMode,
            value: currentFilterValue
        }, newShowMissing);

        card.dataset.showMissing = String(newShowMissing);

        // Clear and re-add warning
        const existingWarnings = card.querySelectorAll('.missing-data-warning');
        existingWarnings.forEach(warning => warning.remove());
        addMissingDataWarning(card, newAgg, getIncludedRows().length, newShowMissing);

        sub.textContent = `${newAgg.rows.length} groups Â· ${newAgg.header[1]}`;
        renderAggTable(newAgg, tableBox, 20, newShowMissing);

        chartsContainer.querySelectorAll('.chart-card').forEach(chartCard => {
            const canvas = chartCard.querySelector('canvas');
            const typeSel = chartCard.querySelector('select');
            const topNInput = chartCard.querySelector('input[type="number"]');
            if (canvas && typeSel && topNInput) {
                const cfg = computeChartConfig(newAgg, typeSel.value, Number(topNInput.value) || 20);
                ensureChart(canvas, cfg, true);
            }
        });
        
        const mainContent = $('#main-content');
        const grid = $('#results');
        const scrollY = mainContent.scrollTop;
        
        grid.style.opacity = '0.5';

        requestAnimationFrame(() => {
            mainContent.scrollTop = scrollY;
            grid.style.opacity = '1';
            applyMasonryLayout();
        });
        
        // After re-rendering, regenerate the explanation
        generateExplanation(newAgg, job, card);
    }

    // Initial render
    // Add a final session check before expensive aggregation
    if (sessionId && window.currentAggregationSession && window.currentAggregationSession !== sessionId) {
        console.log(`â¹ï¸ Skipping groupAgg due to session mismatch before initial aggregation`);
        const dummyCard = document.createElement('div');
        dummyCard.style.display = 'none';
        return dummyCard;
    }
    
    console.time(`buildAggCard:compute:${card.dataset.canonicalKey}`);
    const initialAgg = groupAgg(getIncludedRows(), job.groupBy, job.metric, job.agg, job.dateBucket || '', {
        mode: filterMode,
        value: filterValue
    }, showMissing);
    console.timeEnd(`buildAggCard:compute:${card.dataset.canonicalKey}`);
 
    addMissingDataWarning(card, initialAgg, getIncludedRows().length, showMissing);
    sub.textContent = `${initialAgg.rows.length} groups Â· ${initialAgg.header[1]}`;
 
    console.time(`buildAggCard:renderTable:${card.dataset.canonicalKey}`);
    renderAggTable(initialAgg, tableBox, 20, showMissing);
    console.timeEnd(`buildAggCard:renderTable:${card.dataset.canonicalKey}`);
 
    // Log chart render start and end times per chart card
    charts.forEach((chartSnap, ci) => {
        const chartLabel = `buildAggCard:renderChart:${card.dataset.canonicalKey}:chart${ci}`;
        console.time(chartLabel);
        const chartCard = renderChartCard(initialAgg, chartsContainer, chartSnap.type, chartSnap.topN, title.replace(/\s+/g, '_'), { noAnimation });
        // If renderChartCard returns synchronously, end the timer immediately; otherwise end in ensureChart callbacks
        console.timeEnd(chartLabel);
    });

    if (explanation) {
        const { contentEl, regenerateBtn } = renderExplanationCard(card, `AI Explanation for ${title}`, marked.parse(explanation));
        regenerateBtn.onclick = () => {
            contentEl.innerHTML = '<p>Generating explanation...</p>';
            regenerateBtn.disabled = true;
            generateExplanation(initialAgg, job, card);
        };
    } else if (!skipExplanation) {
        // Don't await here, let it run in the background but track the promise
        const explanationPromise = generateExplanation(initialAgg, job, card);
        return { card, initialAgg, job, explanationPromise };
    }
 
    return { card, initialAgg, job };
}

async function getAiAnalysisPlan(context) {
    const columns = context.profile.columns.map(c => c.name);
    const erpPriority = getErpAnalysisPriority(columns);

    if (erpPriority && erpPriority.metrics.length > 0 && erpPriority.dimensions.length > 0) {
        console.log('[Debug] getAiAnalysisPlan: ERP priority plan detected:', JSON.stringify(erpPriority, null, 2));
        const jobs = [];
        const primaryMetric = erpPriority.metrics[0];
        console.log('[Debug] getAiAnalysisPlan: Primary metric selected:', JSON.stringify(primaryMetric, null, 2));
        
        // Create jobs based on the prioritized dimensions
        erpPriority.dimensions.forEach(dim => {
            if (dim && columns.includes(dim)) {
                jobs.push({
                    groupBy: dim,
                    metric: primaryMetric.type === 'derived' ? primaryMetric.baseMetric : primaryMetric.name,
                    agg: 'sum' // Default to sum for ERP metrics
                });
            }
        });

        return {
            tasks: [{
                description: 'Run ERP-specific analysis based on metric priorities',
                type: 'erp-analysis'
            }],
            jobs: jobs
        };
    }

    // Fallback to a generic plan if no ERP pattern is matched.
    console.log('No specific ERP plan matched. Using generic fallback.');
    const plan = autoPlan(context.profile, context.includedRows, context.excludedDimensions);
    return {
        tasks: [{
            description: 'Run standard automatic analysis',
            type: 'auto-analysis'
        }],
        jobs: plan.jobs
    };
}

async function runAiWorkflow(includedRows, excludedDimensions = []) {
  const apiKey = localStorage.getItem('gemini_api_key');
  if (!apiKey || apiKey.trim() === '') {
    console.log('No API key found, skipping AI workflow.');
    // Hide all AI explanation sections if no API key is present
    document.querySelectorAll('.ai-explanation').forEach(el => el.style.display = 'none');
    // Fallback to a default, non-AI plan if necessary
    // Initialize workflow even for non-AI fallback
    WorkflowManager.reset(MODE);
    WorkflowManager.start();
    workflowTimer.start();
    
    WorkflowManager.completeTask('init');
    await new Promise(resolve => setTimeout(resolve, 50));
    
    const plan = autoPlan(PROFILE, includedRows, excludedDimensions);
    WorkflowManager.completeTask('analysis', 'Using non-AI fallback.');
    WorkflowManager.completeTask('ai-generation', 'Using automatic plan generation.');
    return plan;
  } else {
    WorkflowManager.reset(MODE);
    WorkflowManager.start();
    workflowTimer.start();
    
    try {
        WorkflowManager.completeTask('init');
        
        await new Promise(resolve => setTimeout(resolve, 50)); // Brief pause for UI update
        
        let plan;
        if (MODE === 'manual') {
            plan = MANUAL_JOBS.length ? { jobs: MANUAL_JOBS.slice(0, 10) } : planFromManualRoles(PROFILE);
            WorkflowManager.completeTask('analysis', 'Using manual roles.');
            WorkflowManager.completeTask('config');
        } else {
            const context = {
                profile: PROFILE,
                includedRows: includedRows.slice(0, 5), // Sample rows
                excludedDimensions,
                maxCharts: 10
            };
            
            const dynamicPlan = await getAiAnalysisPlan(context);
            AITasks.loadPlan(WorkflowManager.getCurrentAgentId(), dynamicPlan.tasks);
            
            plan = { jobs: dynamicPlan.jobs, charts: [] }; // Assuming getAiAnalysisPlan also returns jobs
            
            // Don't complete analysis task yet - wait until after cards are built
        }

        window.CURRENT_PLAN = plan;
        workflowTimer.stop();
        return plan;

    } catch (error) {
        console.error("AI workflow failed:", error);
        workflowTimer.stop();
        WorkflowManager.fail(error);
        showToast(`An error occurred during AI analysis: ${error.message}`, 'error');
        return null;
    } finally {
        // Cleanup resources
        workflowTimer.stop();
    }
  }
}

// Global flag to prevent concurrent executions
let isRenderingAggregates = false;
let pendingRender = false;

async function renderAggregates(chartsSnapshot = null, excludedDimensions = [], fallbackDepth = 0, retry = false) {
    if (!ROWS) return showToast('Load a CSV first.', 'error');

    // Prevent concurrent executions
    if (isRenderingAggregates && !retry) {
        console.log('â¸ï¸ renderAggregates already running, queueing next run');
        pendingRender = true;
        return;
    }
    
    isRenderingAggregates = true;
    console.log('ğŸš€ Starting renderAggregates', { chartsSnapshot: !!chartsSnapshot, retry });

    try {
        const includedRows = getIncludedRows();
        if (includedRows.length === 0) {
            showToast('No rows selected for aggregation. Please check some rows in the Raw Data table.', 'warning');
            return;
        }

        const grid = $('#results');
        if (!grid) {
            console.error('Results container not found');
            showToast('Results container not found. Please refresh the page.', 'error');
            return;
        }
        
        // Always clear the grid when starting fresh (not a retry)
        if (!retry) {
            console.log('ğŸ§¹ Clearing existing aggregates');
            grid.innerHTML = '';
        }

        if (chartsSnapshot && chartsSnapshot.length > 0) {
            WorkflowManager.reset();
            for (const cardSnap of chartsSnapshot) {
                const jobKey = cardSnap.cardJobKey || {};
                const result = await buildAggCard(jobKey, cardSnap);
                const newCard = result.card || result;
                grid.appendChild(newCard);
            }
            setTimeout(applyMasonryLayout, 150);
            setTimeout(applyMasonryLayout, 500);
        } else {
            const plan = await runAiWorkflow(includedRows, excludedDimensions);
            
            if (plan && plan.jobs) {
                // Create session ID for this aggregation batch
                const aggregationSessionId = `agg_${Date.now()}_${Math.random().toString(36).slice(2)}`;
                window.currentAggregationSession = aggregationSessionId;
                console.log(`ğŸ†” Starting aggregation session: ${aggregationSessionId}`);
                
                // Use canonical deduplication (more robust than manual dedup)
                const uniqueJobs = deduplicateJobs(plan.jobs);
                if (uniqueJobs.length !== plan.jobs.length) {
                    plan.jobs = uniqueJobs;
                }
                // Track explanation promises for proper workflow completion
                const explanationPromises = [];
                
                const processJobsIncrementally = async () => {
                    for (let i = 0; i < plan.jobs.length; i++) {
                        const job = plan.jobs[i];
                        if (WorkflowManager.getState().status !== 'running') break;
                        
                        // Check if session is still current (prevents stale results)
                        if (window.currentAggregationSession !== aggregationSessionId) {
                            console.log(`â¹ï¸ Skipping job due to session mismatch: current=${window.currentAggregationSession}, expected=${aggregationSessionId}`);
                            break;
                        }
                        
                        console.log(`ğŸ”¨ Building card ${i + 1}/${plan.jobs.length}: ${job.agg}(${job.metric}) by ${job.groupBy} [session: ${aggregationSessionId}]`);
                        const result = await buildAggCard(job, {}, aggregationSessionId);
                        
                        // Double-check session before DOM insertion
                        if (window.currentAggregationSession === aggregationSessionId) {
                            grid.appendChild(result.card);
                            
                            // Track explanation promises if they were started
                            if (result.explanationPromise) {
                                explanationPromises.push(
                                    result.explanationPromise.catch(error => {
                                        console.warn(`Explanation generation failed for card ${i + 1}:`, error);
                                        return null; // Continue even if explanation fails
                                    })
                                );
                            }
                        } else {
                            console.log(`â¹ï¸ Discarding card due to session change`);
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                };
                
                await processJobsIncrementally();
                
                // Complete analysis task now that we're ready to build cards
                WorkflowManager.completeTask('auto-analysis', 'AI analysis plan created. Building cards...');
                
                if (WorkflowManager.getState().status === 'running') {
                    WorkflowManager.completeTask('rendering');
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    // Wait for all explanation promises to complete before marking ai-explanation as done
                    if (explanationPromises.length > 0) {
                        console.log(`â³ Waiting for ${explanationPromises.length} explanation(s) to complete...`);
                        WorkflowManager.updateCurrentTaskMessage(`Generating ${explanationPromises.length} explanations...`);
                        
                        // Monitor progress of explanations
                        let completedCount = 0;
                        const progressPromises = explanationPromises.map((promise, index) =>
                            promise.finally(() => {
                                completedCount++;
                                WorkflowManager.updateCurrentTaskMessage(`Completed ${completedCount}/${explanationPromises.length} explanations...`);
                                
                                // Auto-save after each explanation is completed
                                console.log(`ğŸ”„ Triggering auto-save after explanation ${completedCount}/${explanationPromises.length}...`);
                                debouncedAutoSave();
                            })
                        );
                        
                        try {
                            await Promise.allSettled(progressPromises);
                            console.log(`âœ… All ${explanationPromises.length} explanations completed`);
                            
                            // Auto-save after all explanations are completed
                            console.log(`ğŸ”„ Triggering final auto-save after all ${explanationPromises.length} explanations completed...`);
                            debouncedAutoSave();
                        } catch (error) {
                            console.warn('Some explanations may have failed:', error);
                        }
                    } else {
                        console.log('â„¹ï¸ No explanations to generate');
                    }
                    
                    WorkflowManager.completeTask('ai-explanation');
                    await new Promise(resolve => setTimeout(resolve, 50));
                    WorkflowManager.completeTask('completion');
                    
                    
                    // Stop timer and cleanup on completion
                    workflowTimer.stop();
                    console.log('â¹ï¸ Workflow timer stopped on completion');
                    
                    // Force a final UI update to show completion state
                    setTimeout(() => {
                        const finalState = WorkflowManager.getState();
                        console.log('ğŸ” Final workflow state:', finalState.status, finalState.tasks.map(t => `${t.description}: ${t.status}`));
                        updateAiTodoList(finalState);
                    }, 100);
                    
                    showToast('Analysis completed successfully.', 'success');
                    
                    // Auto-save after successful card generation
                    debouncedAutoSave();
                }
                setTimeout(applyMasonryLayout, 150);
                setTimeout(applyMasonryLayout, 500);
            } else {
                // Fallback when AI workflow fails: use basic auto plan
                console.log('ğŸ”„ AI workflow failed, falling back to basic auto plan');
                const fallbackPlan = autoPlan(PROFILE, includedRows, excludedDimensions);
                
                if (fallbackPlan && fallbackPlan.jobs) {
                    // Create session ID for this aggregation batch
                    const aggregationSessionId = `agg_${Date.now()}_${Math.random().toString(36).slice(2)}`;
                    window.currentAggregationSession = aggregationSessionId;
                    console.log(`ğŸ†” Starting fallback aggregation session: ${aggregationSessionId}`);
                    
                    // Use canonical deduplication
                    const uniqueJobs = deduplicateJobs(fallbackPlan.jobs);
                    if (uniqueJobs.length !== fallbackPlan.jobs.length) {
                        fallbackPlan.jobs = uniqueJobs;
                    }
                    
                    // Build cards for fallback plan (without AI explanations)
                    for (let i = 0; i < fallbackPlan.jobs.length; i++) {
                        const job = fallbackPlan.jobs[i];
                        console.log(`ğŸ”¨ Building fallback card ${i + 1}/${fallbackPlan.jobs.length}: ${job.agg}(${job.metric}) by ${job.groupBy}`);
                        const result = await buildAggCard(job, {}, aggregationSessionId, { skipExplanation: true });
                        
                        if (window.currentAggregationSession === aggregationSessionId) {
                            grid.appendChild(result.card);
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    
                    setTimeout(applyMasonryLayout, 150);
                    setTimeout(applyMasonryLayout, 500);
                    showToast('Analysis completed using basic plan (AI workflow failed).', 'warning');
                    
                    // Auto-save after fallback card generation
                    debouncedAutoSave();
                }
            }
        }
        
        // After all cards are rendered (either from snapshot or new plan), generate the summary
        checkAndGenerateAISummary();
        
    } finally {
        isRenderingAggregates = false;
        console.log('âœ… renderAggregates completed');
        if (pendingRender) {
            const wasPending = pendingRender;
            pendingRender = false;
            console.log('ğŸ” Running queued renderAggregates');
            setTimeout(() => {
                try { renderAggregates(null, [], 0, true); } catch (e) { console.error(e); }
            }, 0);
        }
    }
}

/* ========= Modal accessibility: ESC & backdrop ========= */
document.addEventListener('keydown', e=>{ if(e.key==='Escape'){ document.querySelectorAll('.modal.open').forEach(m=>m.classList.remove('open')); }});

['roleModal','aggModal', 'historyModal', 'removedRowsModal', 'aiSettingsModal'].forEach(id=>{ const m = document.getElementById(id); m?.addEventListener('click', (e)=>{ if (e.target===m) m.classList.remove('open'); }); });
$('#closeRemovedRowsModal').onclick = () => $('#removedRowsModal').classList.remove('open');

/* ========= Manual Save Handlers ========= */
$('#updateReportBtn').onclick = () => {
  if (!ROWS) return showToast('No data loaded to update.', 'error');
  if (!window.currentHistoryId) return showToast('No active report selected to update.', 'error');
  
  const currentName = $('#history-list .history-item[data-id="' + window.currentHistoryId + '"] .name')?.textContent || 'current report';
  if (confirm(`Are you sure you want to overwrite "${currentName}" with the current view?`)) {
    saveCurrentStateToHistory(currentName, false); // false = update existing
  }
};

$('#saveAsNewBtn').onclick = () => {
  if (!ROWS) return showToast('No data loaded to save.', 'error');
  
  const baseName = (LAST_PARSE_META && LAST_PARSE_META.fileName)
    ? LAST_PARSE_META.fileName.replace(/\.csv$/i, '')
    : 'Report';
  const defaultName = `${baseName} (copy) ${getFormattedDateTime()}`;
    
  const reportName = prompt('Enter a name for the new report:', defaultName);
  
  if (reportName) {
    saveCurrentStateToHistory(reportName, true); // true = force new entry
  }
};
/* ========= History Sidebar ========= */
const sidebar = $('#sidebar');
const toggleBtn = $('#sidebar-toggle');
// Accessibility: link button with sidebar and manage expanded state
toggleBtn.setAttribute('aria-controls', 'sidebar');

const SIDEBAR_COLLAPSE_KEY = 'csv-chart-v5:sidebar-collapsed';
function updateSidebarToggleA11y(){
  const expanded = !sidebar.classList.contains('collapsed');
  toggleBtn.setAttribute('aria-expanded', String(expanded));
  toggleBtn.setAttribute('aria-label', expanded ? 'Collapse sidebar' : 'Expand sidebar');
  const announcer = document.getElementById('sr-announcer');
  if (announcer) {
    announcer.textContent = expanded ? 'Sidebar expanded' : 'Sidebar collapsed';
  }
}
function applyStoredSidebarState(){
  try {
    const collapsed = localStorage.getItem(SIDEBAR_COLLAPSE_KEY) === '1';
    sidebar.classList.toggle('collapsed', collapsed);
  } catch {}
  updateSidebarToggleA11y();
}
toggleBtn.addEventListener('click', () => {
  const hadFocusInside = sidebar.contains(document.activeElement);
  const prevFocus = document.activeElement;

  sidebar.classList.toggle('collapsed');

  try {
    localStorage.setItem(SIDEBAR_COLLAPSE_KEY, sidebar.classList.contains('collapsed') ? '1' : '0');
  } catch {}

  updateSidebarToggleA11y();

  if (hadFocusInside) {
    requestAnimationFrame(() => {
      try {
        if (prevFocus && typeof prevFocus.focus === 'function' && document.contains(prevFocus)) {
          prevFocus.focus();
          return;
        }
      } catch {}
      const list = document.getElementById('history-list');
      const fallback = list?.querySelector('.history-item.active') || list?.querySelector('.history-item') || toggleBtn;
      fallback?.focus();
    });
  }
});
// Initialize from storage on load
applyStoredSidebarState();

async function renderHistorySidebar() {
  const list = $('#history-list');
  const searchInput = $('#history-search');
  const searchTerm = (searchInput.value || '').toLowerCase();
  list.innerHTML = '<li>Loading...</li>';
  try {
    let historyItems = await Store.listHistory();
    
    if (searchTerm) {
      historyItems = historyItems.filter(item =>
        (item.name || '').toLowerCase().includes(searchTerm)
      );
    }

    list.innerHTML = '';
    if (!historyItems.length) {
      list.innerHTML = `<li class="muted small" style="padding: 0 var(--s-4);">${searchTerm ? 'No matching reports found.' : 'No history yet.'}</li>`;
      return;
    }
    for (const item of historyItems) {
      const li = document.createElement('li');
      li.className = 'history-item';
      li.setAttribute('data-id', item.id);
      li.setAttribute('data-tooltip', item.name || 'Untitled');
      // a11y + keyboard: make entire item focusable and operable
      li.setAttribute('tabindex', '0');
      li.setAttribute('role', 'option');
      li.setAttribute('aria-label', item.name || 'Untitled');
      li.title = item.name || 'Untitled';
      if (item.id === window.currentHistoryId) {
        li.classList.add('active');
        li.setAttribute('aria-current', 'true');
        li.setAttribute('aria-selected', 'true');
      } else {
        li.removeAttribute('aria-selected');
      }

      const nameSpan = document.createElement('div');
      nameSpan.className = 'name';
      nameSpan.textContent = item.name || 'Untitled';
      nameSpan.title = item.name || 'Untitled';

      const metaDiv = document.createElement('div');
      metaDiv.className = 'meta';
      
      const dateSpan = document.createElement('span');
      dateSpan.innerHTML = `ğŸ“… ${new Date(item.updatedAt).toLocaleDateString()}`;
      
      const rowsSpan = document.createElement('span');
      rowsSpan.innerHTML = `â‰¡ ${item.rowCount.toLocaleString()} rows`;

      const colsSpan = document.createElement('span');
      colsSpan.innerHTML = `ğŸ“Š ${item.columns.length} cols`;

      metaDiv.append(dateSpan, rowsSpan, colsSpan);

      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'actions';

      const loadBtn = document.createElement('button');
      loadBtn.className = 'load-btn';
      loadBtn.textContent = 'Load';
      loadBtn.onclick = (e) => {
        e.stopPropagation(); // prevent li click
        loadHistoryState(item.id);
      };
      
      if (item.status && item.status !== 'ready') {
        loadBtn.textContent = `Saving...`;
        loadBtn.disabled = true;
      }

      actionsDiv.appendChild(loadBtn);
      
      // Click anywhere on the item to load (buttons stop propagation)
      li.addEventListener('click', () => { loadHistoryState(item.id); });
      // Keyboard support: Enter/Space to load; ArrowUp/Down/Home/End to navigate
      li.addEventListener('keydown', (e) => {
        const key = e.key;
        if (key === 'Enter' || key === ' ') {
          e.preventDefault();
          loadHistoryState(item.id);
          return;
        }
        const items = Array.from(list.querySelectorAll('.history-item'));
        const i = items.indexOf(li);
        if (key === 'ArrowDown') {
          e.preventDefault();
          const next = items[Math.min(items.length - 1, i + 1)];
          next?.focus();
        } else if (key === 'ArrowUp') {
          e.preventDefault();
          const prev = items[Math.max(0, i - 1)];
          prev?.focus();
        } else if (key === 'Home') {
          e.preventDefault();
          items[0]?.focus();
        } else if (key === 'End') {
          e.preventDefault();
          items[items.length - 1]?.focus();
        }
      });
      
      li.append(nameSpan, metaDiv, actionsDiv);
      list.appendChild(li);
    }
  } catch (e) {
    console.error('Failed to render history', e);
    list.innerHTML = '<li class="muted small error">Could not load history.</li>';
  }
}

function getUiSnapshot() {
  const sectionStates = {};
  document.querySelectorAll('.section').forEach(section => {
    const header = section.querySelector('.section-header');
    if (header) {
      const headingEl = header.querySelector('h2, h3, h4');
      const headingText = headingEl ? headingEl.textContent.trim() : '';
      if (headingText) {
        const sectionId = headingText.replace(/\s+/g, '-').toLowerCase();
        sectionStates[sectionId] = section.classList.contains('is-collapsed');
      }
    }
  });

  // Capture AI Summary content if it exists
  const aiSummaryText = document.getElementById('ai-summary-text');
  const aiSummaryContent = aiSummaryText ? aiSummaryText.innerHTML : null;
  const aiSummaryVisible = document.getElementById('ai-summary-section')?.style.display !== 'none';

  return {
    mode: MODE,
    manualRoles: MANUAL_ROLES,
    manualJobs: MANUAL_JOBS,
    sort: SORT,
    query: QUERY,
    page: PAGE,
    rpp: RPP,
    autoExclude: AUTO_EXCLUDE,
    currencyTokens: CURRENCY_TOKENS,
    rowInclusion: ROW_INCLUDED,
    charts: getChartsSnapshot(), // Capture the state of all rendered charts
    sectionCollapsedState: sectionStates,
    aiSummary: {
      content: aiSummaryContent,
      visible: aiSummaryVisible,
      timestamp: aiSummaryContent ? Date.now() : null
    }
  };
}

async function saveCurrentStateToHistory(fileName, forceNew = false) {
  if (!ROWS || !PROFILE) return;

  const toastId = `toast-${Date.now()}`;
  showToast('Saving report... 0%', 'info', 999999, toastId);

  try {
    const isUpdating = !forceNew && window.currentHistoryId;
    
    let finalName = fileName || 'Untitled Report';
    if (!isUpdating) {
      finalName = `${finalName.replace(/\s\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}$/, '')} ${getFormattedDateTime()}`;
    }

    const historyItem = {
      id: isUpdating ? window.currentHistoryId : crypto.randomUUID(),
      sig: signatureFromHeaders(),
      name: finalName,
      columns: DATA_COLUMNS,
      rowCount: ROWS.length,
      meta: LAST_PARSE_META,
      uiSnapshot: getUiSnapshot(),
      status: 'saving',
    };

    const id = await Store.saveHistory(historyItem);
    window.currentHistoryId = id;
    await renderHistorySidebar();

    // Optimization: If updating, check if rows have changed. If not, only update metadata.
    if (isUpdating) {
      const existing = await Store.getHistory(id);
      const sameRows = existing && existing.rowCount === ROWS.length && existing.sig === signatureFromHeaders();
      if (sameRows) {
        console.log('Optimization: UI-only change detected. Updating snapshot without re-uploading chunks.');
        await Store.updateHistory(id, { uiSnapshot: getUiSnapshot(), updatedAt: Date.now(), status: 'ready' });
        await renderHistorySidebar();
        showToast('Report updated (UI settings saved).', 'success', 3000, toastId);
        return; // Skip chunk re-upload
      }
    }

    try {
      const chunkSize = 5000;
      const totalChunks = Math.ceil(ROWS.length / chunkSize);
      let idx = 0;
      for (let i = 0; i < ROWS.length; i += chunkSize) {
        const chunk = ROWS.slice(i, i + chunkSize);
        await Store.appendChunk(id, idx++, chunk);
        const progress = Math.round((idx / totalChunks) * 100);
        showToast(`Saving report... ${progress}%`, 'info', 999999, toastId);
        if (idx % 5 === 0) await new Promise(r => setTimeout(r, 0));
      }
      
      await Store.updateHistory(id, { status: 'ready' });
      showToast('Report saved successfully!', 'success', 3000, toastId);
    } catch (e) {
      console.error('Chunk saving failed:', e);
      await Store.updateHistory(id, { status: 'error' });
      showToast('Failed to save report data.', 'error', 3000, toastId);
    } finally {
      await renderHistorySidebar();
    }
  } catch (e) {
    console.error('Failed to save history', e);
    showToast('Failed to save history.', 'error', 3000, toastId);
  }
}

function getChartsSnapshot() {
  const charts = [];
  document.querySelectorAll('#results .card').forEach(card => {
    const cardTitle = card.querySelector('.card-title')?.textContent || '';
    const cardCharts = [];
    const explanationEl = card.querySelector('.ai-explanation-content');
    // Get the raw markdown/text if stored, otherwise get the rendered HTML
    const explanation = card.dataset.explanationMarkdown || (explanationEl ? explanationEl.innerHTML : null);

    // The job key is stored directly on the card's dataset
    const ds = card.dataset || {};
    const jobKey = {
      groupBy: ds.groupBy || '',
      metric: ds.metric || null,
      agg: ds.agg || 'sum',
      dateBucket: ds.dateBucket || ''
    };

    card.querySelectorAll('.chart-card').forEach(chartCard => {
      const type = chartCard.querySelector('select')?.value || 'auto';
      const topN = chartCard.querySelector('input[type="number"]')?.value || '20';
      cardCharts.push({ type, topN });
    });

    const filterInput = card.querySelector('.filter-input');
    const filterModeSelect = card.querySelector('.filter-mode-select');

    charts.push({
      title: cardTitle,
      cardJobKey: jobKey,
      charts: cardCharts,
      filterValue: filterInput ? filterInput.value : 0,
      filterMode: filterModeSelect ? filterModeSelect.value : 'share',
      explanation: explanation,
      showMissing: card.dataset.showMissing === 'true'
    });
  });
  return charts;
}

async function loadHistoryState(id) {
  const isNewFile = sessionStorage.getItem('isNewFileLoad') === 'true';
  if (isNewFile) {
    console.log('[Workflow] New file load detected, aborting history load and forcing fresh analysis.');
    sessionStorage.removeItem('isNewFileLoad');
    if (ROWS && PROFILE) {
        renderAggregates();
    } else {
        showToast('Cannot perform fresh analysis: data not loaded.', 'error');
    }
    return;
  }
  const toastId = `toast-${Date.now()}`;
  showToast('Loading report... 0%', 'info', 999999, toastId);
  
  // Stage 1: Read and validate snapshot WITHOUT touching current UI
  let result, history, rows, snapshot;
  try {
    const onProgress = (loaded, total) => {
      const progress = total > 0 ? Math.round((loaded / total) * 100) : 100;
      showToast(`Loading report... ${progress}%`, 'info', 999999, toastId);
    };

    result = await Store.restoreHistory(id, onProgress);
    if (!result) {
      showToast('History item not found.', 'error', 3000, toastId);
      return;
    }
    
    ({ history, rows } = result);

    if (history.status === 'saving') {
      showToast('This report is still saving. Please wait.', 'info', 3000, toastId);
      return;
    }
    if (history.status === 'error') {
      showToast('This report is corrupted and cannot be loaded.', 'error', 3000, toastId);
      return;
    }
    if (!rows || !Array.isArray(rows)) {
      showToast('Failed to load report data.', 'error', 3000, toastId);
      return;
    }
    
    // Validate critical snapshot data
    snapshot = history.uiSnapshot || {};
    if (!history.columns || !Array.isArray(history.columns)) {
      showToast('Report data is corrupted (missing columns).', 'error', 3000, toastId);
      return;
    }
    
    console.log('âœ… Snapshot validation passed:', { 
      rows: rows.length, 
      columns: history.columns.length, 
      hasCharts: !!(snapshot.charts && Array.isArray(snapshot.charts))
    });
    
    // Set global data for chat and other components
    window.currentData = rows;
    
  } catch (error) {
    console.error('Failed to load or validate history:', error);
    showToast('Error loading report: ' + (error.message || 'Unknown error'), 'error', 3000, toastId);
    return;
  }
  
  // Stage 2: Backup current state for rollback
  const backup = {
    rows: ROWS,
    columns: DATA_COLUMNS,
    meta: LAST_PARSE_META,
    profile: PROFILE,
    mode: MODE,
    manualRoles: MANUAL_ROLES,
    manualJobs: MANUAL_JOBS,
    sort: SORT,
    query: QUERY,
    page: PAGE,
    rpp: RPP,
    autoExclude: AUTO_EXCLUDE,
    currencyTokens: CURRENCY_TOKENS,
    rowInclusion: ROW_INCLUDED,
    currentHistoryId: window.currentHistoryId
  };
  
  // Stage 3: Apply new state with error recovery
  try {

    showToast(`Restoring "${history.name || 'Untitled'}"...`, 'info', 999999, toastId);
    
    // Restore data
    ROWS = rows;
    DATA_COLUMNS = history.columns || [];
    LAST_PARSE_META = history.meta || {};
    PROFILE = profile(ROWS);
    
    // Restore UI state from snapshot
    MODE = snapshot.mode || 'auto';
    MANUAL_ROLES = snapshot.manualRoles || {};
    MANUAL_JOBS = snapshot.manualJobs || [];
    SORT = snapshot.sort || { col: null, dir: 'asc' };
    QUERY = snapshot.query || '';
    PAGE = snapshot.page || 1;
    RPP = snapshot.rpp || 25;
    AUTO_EXCLUDE = (typeof snapshot.autoExclude === 'boolean') ? snapshot.autoExclude : true;
    if (Array.isArray(snapshot.currencyTokens) && snapshot.currencyTokens.length > 0) {
      CURRENCY_TOKENS = snapshot.currencyTokens;
    }
    if (Array.isArray(snapshot.rowInclusion)) {
       if (snapshot.rowInclusion.length === ROWS.length) {
         ROW_INCLUDED = snapshot.rowInclusion;
       } else {
         console.warn('history rowInclusion length mismatch; adjusting saved inclusion to current rows');
         const arr = snapshot.rowInclusion.slice(0, ROWS.length);
         while (arr.length < ROWS.length) arr.push(true);
         ROW_INCLUDED = arr;
       }
     } else {
      initializeRowInclusion();
     }
    
    if (snapshot.sectionCollapsedState) {
      document.querySelectorAll('.section').forEach(section => {
        const header = section.querySelector('.section-header');
        if (header) {
          const headingEl = header.querySelector('h2, h3, h4');
          const headingText = headingEl ? headingEl.textContent.trim() : '';
          if (headingText) {
            const sectionId = headingText.replace(/\s+/g, '-').toLowerCase();
            if (snapshot.sectionCollapsedState[sectionId] === true) {
              section.classList.add('is-collapsed');
              const btn = header.querySelector('.section-toggle');
              if(btn) {
                btn.setAttribute('aria-expanded', 'false');
                btn.setAttribute('aria-label', `Show ${headingText}`);
                
                // Update button text properly without breaking structure
                const buttonTextEl = btn.querySelector('.button-text');
                if (buttonTextEl) {
                  buttonTextEl.textContent = 'Show';
                } else {
                  // Fallback: if button doesn't have proper structure, set textContent
                  btn.textContent = 'Show';
                }
                
                const content = section.querySelector('.section-content');
                if(content) content.setAttribute('aria-hidden', 'true');
              }
            }
          }
        }
      });
    }

    // Restore AI Summary if it was saved
    if (snapshot.aiSummary) {
      const aiSummarySection = document.getElementById('ai-summary-section');
      const aiSummaryText = document.getElementById('ai-summary-text');
      
      if (aiSummarySection && aiSummaryText && snapshot.aiSummary.content) {
        console.log('ğŸ“„ Restoring saved AI Summary');
        aiSummaryText.innerHTML = snapshot.aiSummary.content;
        
        // Show the section if it was visible and API key is available
        const apiKey = localStorage.getItem('gemini_api_key');
        if (snapshot.aiSummary.visible && apiKey && apiKey.trim()) {
          aiSummarySection.style.display = 'block';
          console.log('âœ… AI Summary section restored and shown');
        } else {
          aiSummarySection.style.display = 'none';
          console.log('ğŸ”’ AI Summary content restored but section hidden (no API key or was not visible)');
        }
      }
    }

    // Update UI elements
    $('#meta').textContent = `Loaded ${PROFILE.rowCount.toLocaleString()} rows from history.`;
    $('#searchInput').value = QUERY;
    $('#rowsPerPage').value = RPP;
    $('#autoExclude').checked = AUTO_EXCLUDE;
    $('#mode').value = MODE;
    switchMode(MODE);
    
    // Render everything safely  
    renderProfile(PROFILE, LAST_PARSE_META);
    buildRawHeader(DATA_COLUMNS);
    applyFilter();
    renderRawBody();
    
    // Safe aggregates restoration with validation
    const restoreSessionId = `restore_${Date.now()}`;
    console.log(`ğŸ”„ Starting aggregates restore with session: ${restoreSessionId}`);
    
    const grid = $('#results');
    if (grid) grid.innerHTML = ''; // Clear grid for both cases

    if (snapshot.charts && Array.isArray(snapshot.charts) && snapshot.charts.length > 0) {
        console.log(`ğŸ“Š Restoring ${snapshot.charts.length} saved charts`);
 
        // Step 1: Build all cards in parallel without generating new explanations
        const cardBuildPromises = snapshot.charts.map((cardSnap, idx) => {
            const jobKey = cardSnap.cardJobKey || {};
            console.log(`â± buildPhase start: card#${idx} key=${(jobKey.groupBy||'')}/${(jobKey.metric||'')}/${(jobKey.agg||'')}`);
            // Pass noAnimation flag down to buildAggCard
            return buildAggCard(jobKey, { ...cardSnap, noAnimation: true }, null, { skipExplanation: true })
              .then(res => {
                console.log(`â± buildPhase done: card#${idx} key=${res.card.dataset.canonicalKey}`);
                return res;
              });
        });
 
        console.time('restore:PromiseAll:cards');
        const cardDataArray = await Promise.all(cardBuildPromises);
        console.timeEnd('restore:PromiseAll:cards');
        console.log('â± All card builds resolved (Promise.all). Appending cards to DOM now.');
 
        // Append all cards to the DOM at once so they appear together
        const appendStart = Date.now();
        cardDataArray.forEach((data, i) => {
            grid.appendChild(data.card);
        });
        const appendEnd = Date.now();
        console.log(`â± Appended ${cardDataArray.length} cards to DOM (took ${appendEnd - appendStart} ms)`);
 
        // Apply layout after cards are in the DOM
        setTimeout(() => {
            console.log('â± applyMasonryLayout scheduled (150ms)');
            applyMasonryLayout();
        }, 150);
        setTimeout(() => {
            console.log('â± applyMasonryLayout scheduled (500ms)');
            applyMasonryLayout();
        }, 500);
 
        // Step 2: Sequentially generate explanations for cards that don't have one
        console.log('ğŸ¤– Starting sequential AI explanation generation for cards missing it...');
        // Step 2: Sequentially update the workflow UI and generate explanations
        console.log('ğŸ¤– Starting sequential UI update and AI explanation generation...');
        WorkflowManager.reset('auto');
        WorkflowManager.start();

        // Use small delays to make the UI progression feel natural
        await new Promise(r => setTimeout(r, 50));
        WorkflowManager.completeTask('init', 'Session initialized from history.');
        
        await new Promise(r => setTimeout(r, 50));
        WorkflowManager.completeTask('analysis', 'Data profile loaded from history.');
        
        await new Promise(r => setTimeout(r, 50));
        WorkflowManager.completeTask('ai-generation', 'Chart recommendations loaded from history.');
        
        await new Promise(r => setTimeout(r, 50));
        WorkflowManager.completeTask('rendering', 'Charts and tables rendered.');

        const explanationTasks = [];
        for (let i = 0; i < cardDataArray.length; i++) {
            const { card, initialAgg, job } = cardDataArray[i];
            const cardSnap = snapshot.charts[i];
            
            if (!cardSnap.explanation) {
                explanationTasks.push({ agg: initialAgg, jobKey: job, card, index: i });
            } else {
                console.log(`â„¹ï¸ Card #${i} already has explanation in snapshot; skipping generation.`);
            }
        }

        if (explanationTasks.length > 0) {
            // This task is now 'in-progress'
            WorkflowManager.updateCurrentTaskMessage(`Generating ${explanationTasks.length} new explanations...`);
            for (const [index, task] of explanationTasks.entries()) {
                console.log(`â± generateExplanation queued start: card#${task.index}`);
                WorkflowManager.updateCurrentTaskMessage(`Generating explanation ${index + 1} of ${explanationTasks.length}...`);
                await generateExplanation(task.agg, task.jobKey, task.card);
                console.log(`â± generateExplanation completed: card#${task.index}`);
                
                // Auto-save after each explanation is generated
                console.log(`ğŸ”„ Triggering auto-save after explanation ${index + 1}...`);
                debouncedAutoSave();
            }
            WorkflowManager.completeTask('ai-explanation', `${explanationTasks.length} explanations generated.`);
            
            // Auto-save after all explanations are completed
            console.log(`ğŸ”„ Triggering auto-save after all explanations completed...`);
            debouncedAutoSave();
        } else {
            WorkflowManager.completeTask('ai-explanation', 'All explanations were loaded from history.');
        }
        
        await new Promise(r => setTimeout(r, 50));
        WorkflowManager.completeTask('completion', 'Workflow finished.');
        
        // Check if we should show and generate AI Summary
        checkAndGenerateAISummary();
        
        // Stop timer and cleanup on completion
        workflowTimer.stop();
        console.log('â¹ï¸ Workflow timer stopped on completion (history restore)');
        
        // Force a final UI update to show completion state
        setTimeout(() => {
            const finalState = WorkflowManager.getState();
            console.log('ğŸ” Final workflow state (history restore):', finalState.status, finalState.tasks.map(t => `${t.description}: ${t.status}`));
            updateAiTodoList(finalState);
        }, 100);
        
        console.log('âœ… AI explanations completed.');
    } else {
        console.log('ğŸ“Š No saved charts found, generating fresh aggregates');
    }

    window.currentHistoryId = id;
    showToast(`Loaded "${history.name || 'Untitled'}"`, 'success', 3000, toastId);
    renderHistorySidebar(); // To update active state
    
    // Initialize chat section after history restore
    setTimeout(() => {
      console.log('ğŸ” Chat restore check:', {
        chatSection: !!document.getElementById('ai-analysis-section'),
        hasCurrentData: !!(window.currentData && window.currentData.length > 0),
        dataLength: window.currentData ? window.currentData.length : 0
      });
      
      const chatSection = document.getElementById('ai-analysis-section');
      if (chatSection && window.currentData && window.currentData.length > 0) {
        chatSection.style.display = 'block';
        
        // Try to initialize chat - check if function exists in scope
        if (typeof window.initializeChat === 'function') {
          window.initializeChat();
          console.log('ğŸ“± AI Analysis Chat initialized after history restore');
        } else {
          console.log('âš ï¸ initializeChat function not available yet, will retry...');
          // Retry after a short delay
          setTimeout(() => {
            if (typeof window.initializeChat === 'function') {
              window.initializeChat();
              console.log('ğŸ“± AI Analysis Chat initialized after retry');
            } else {
              console.log('âŒ initializeChat still not available');
            }
          }, 200);
        }
      } else {
        console.log('âŒ Chat initialization failed - missing requirements');
      }
    }, 600);
    
  } catch (restoreError) {
    console.error('Failed during restore - rolling back:', restoreError);
    
    // Rollback to previous state
    try {
      ROWS = backup.rows;
      DATA_COLUMNS = backup.columns;
      LAST_PARSE_META = backup.meta;
      PROFILE = backup.profile;
      MODE = backup.mode;
      MANUAL_ROLES = backup.manualRoles;
      MANUAL_JOBS = backup.manualJobs;
      SORT = backup.sort;
      QUERY = backup.query;
      PAGE = backup.page;
      RPP = backup.rpp;
      AUTO_EXCLUDE = backup.autoExclude;
      CURRENCY_TOKENS = backup.currencyTokens;
      ROW_INCLUDED = backup.rowInclusion;
      window.currentHistoryId = backup.currentHistoryId;
      
      // Restore UI to previous state
      if (ROWS && DATA_COLUMNS) {
        $('#meta').textContent = `${ROWS.length.toLocaleString()} rows loaded.`;
        renderProfile(PROFILE);
        buildRawHeader(DATA_COLUMNS);
        applyFilter();
        renderRawBody();
      }
      
      showToast(`Failed to restore report. Previous state recovered. Error: ${restoreError.message}`, 'error', 5000, toastId);
      console.log('âœ… Rollback completed successfully');
    } catch (rollbackError) {
      console.error('Critical: Rollback failed!', rollbackError);
      showToast('Critical error: Failed to restore report and rollback failed. Please refresh the page.', 'error', 10000, toastId);
    }
  }
}

// Initial render
async function openHistoryManager() {
  const modal = $('#historyModal');
  const listContainer = $('#history-management-list');
  const selectAllCheckbox = $('#history-select-all');
  const deleteSelectedBtn = $('#deleteSelectedBtn');
  
  listContainer.innerHTML = 'Loading...';
  modal.classList.add('open');

  try {
    const historyItems = await Store.listHistory();
    listContainer.innerHTML = '';
    if (!historyItems.length) {
      listContainer.innerHTML = '<div class="muted small" style="padding: 8px;">No history to manage.</div>';
      selectAllCheckbox.disabled = true;
      return;
    }
    selectAllCheckbox.disabled = false;
    selectAllCheckbox.checked = false;

    historyItems.forEach(item => {
      const div = document.createElement('div');
      div.className = 'history-manage-item';
      div.style.display = 'flex';
      div.style.alignItems = 'center';
      div.style.gap = '8px';
      div.style.padding = '8px';
      div.style.border = '1px solid var(--border)';
      div.style.borderRadius = 'var(--radius-xs)';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.setAttribute('data-id', item.id);
      checkbox.className = 'history-item-checkbox';

      const nameSpan = document.createElement('span');
      nameSpan.textContent = item.name;
      nameSpan.style.flexGrow = '1';

      const renameBtn = document.createElement('button');
      renameBtn.textContent = 'Rename';
      renameBtn.onclick = async () => {
        const newName = prompt('Enter new name for this report:', item.name);
        if (newName && newName.trim() !== '') {
          await Store.updateHistory(item.id, { name: newName.trim() });
          showToast('Report renamed.', 'success');
          await renderHistorySidebar();
          openHistoryManager(); // Refresh the modal list
        }
      };

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.style.background = '#fee2e2';
      deleteBtn.style.color = '#b91c1c';
      deleteBtn.style.border = '1px solid #fecaca';
      deleteBtn.onclick = async () => {
        if (confirm(`Are you sure you want to delete "${item.name}"?`)) {
          await Store.deleteHistory(item.id);
          showToast('Report deleted.', 'success');
          await renderHistorySidebar();
          openHistoryManager(); // Refresh the modal list
        }
      };

      div.append(checkbox, nameSpan, renameBtn, deleteBtn);
      listContainer.appendChild(div);
    });

    // Add event listeners for bulk actions
    const checkboxes = listContainer.querySelectorAll('.history-item-checkbox');
    
    function updateDeleteButtonState() {
      const selected = listContainer.querySelectorAll('.history-item-checkbox:checked');
      deleteSelectedBtn.disabled = selected.length === 0;
      if (!deleteSelectedBtn.disabled) {
        deleteSelectedBtn.style.background = '#f87171';
        deleteSelectedBtn.style.color = '#7f1d1d';
        deleteSelectedBtn.style.cursor = 'pointer';
      } else {
        deleteSelectedBtn.style.background = '#fca5a5';
        deleteSelectedBtn.style.color = '#7f1d1d';
        deleteSelectedBtn.style.cursor = 'not-allowed';
      }
    }

    checkboxes.forEach(cb => cb.addEventListener('change', updateDeleteButtonState));
    
    selectAllCheckbox.onchange = () => {
      checkboxes.forEach(cb => cb.checked = selectAllCheckbox.checked);
      updateDeleteButtonState();
    };
    
    updateDeleteButtonState();

  } catch (e) {
    console.error('Failed to load history for management', e);
    listContainer.innerHTML = '<div class="muted small error" style="padding: 8px;">Could not load history.</div>';
  }
}

$('#manageHistoryBtn').onclick = openHistoryManager;
$('#closeHistoryModal').onclick = () => $('#historyModal').classList.remove('open');

$('#deleteSelectedBtn').onclick = async () => {
  const selected = document.querySelectorAll('#history-management-list .history-item-checkbox:checked');
  if (selected.length === 0) return;

  if (confirm(`Are you sure you want to delete ${selected.length} selected report(s)?`)) {
    for (const cb of selected) {
      const id = cb.getAttribute('data-id');
      await Store.deleteHistory(id);
    }
    showToast(`${selected.length} report(s) deleted.`, 'success');
    await renderHistorySidebar();
    openHistoryManager(); // Refresh modal
  }
};

$('#clearAllHistoryBtn').onclick = async () => {
  if (confirm('Are you sure you want to delete ALL saved reports? This action cannot be undone.')) {
    const historyItems = await Store.listHistory();
    for (const item of historyItems) {
      await Store.deleteHistory(item.id);
    }
    showToast('All history has been cleared.', 'success');
    await renderHistorySidebar();
    $('#historyModal').classList.remove('open');
  }
};

document.addEventListener('DOMContentLoaded', () => {
    renderHistorySidebar();
    initializeAiSettingsHandlers({ $, showToast });
    initializeSectionToggles();
    const grid = $('#results');
    if (grid) {
        // The grid is populated dynamically when data is loaded.
    }
});
$('#history-search').addEventListener('input', debounce(renderHistorySidebar, 250));

// Message listener for receiving CSV data from parent window
let csvProcessed = false;
window.addEventListener('message', async (event) => {
  // Verify origin matches current location
  if (event.origin !== window.location.origin) return;
  
  if (event.data && event.data.type === 'table_csv') {
    const { csv, header } = event.data;
    
    console.log('ğŸ” DEBUG: Received table_csv message');
    console.log('ğŸ“‹ Header data:', header);
    console.log('ğŸ“Š CSV data length:', csv ? csv.length : 'null');
    console.log('ğŸ“Š CSV data first 200 chars:', csv ? csv.substring(0, 200) : 'null');
    
    // Prevent duplicate processing
    if (csvProcessed) {
      console.log('âš ï¸ CSV already processed, ignoring duplicate message');
      return;
    }
    
    // Process the CSV data
    if (csv) {
      try {
        sessionStorage.setItem('isNewFileLoad', 'true');
        csvProcessed = true; // Mark as processing to prevent duplicates
        
        // The header parameter contains the report title/description (from headerTableEl)
        // The csv parameter contains: reportHeader + "\r\n\r\n" + actualCSVData
        
        console.log('ğŸ”„ Processing CSV data extraction...');
        
        // The CSV data comes from openAiTableBtn's tableToCsv() function which properly 
        // converts HTML tables to CSV. The structure is: reportHeader + "\r\n\r\n" + properCSV
        let csvData = csv;
        
        // Check for BOM first  
        const hasBOM = csvData.charCodeAt(0) === 0xFEFF;
        console.log('ğŸ” Has BOM:', hasBOM);
        if (hasBOM) {
          csvData = csvData.substring(1);
          console.log('âœ… Removed BOM, new length:', csvData.length);
        }
        
        // Since openAiTableBtn creates: headerData + '\r\n\r\n' + csvBody
        // We need to remove the report header part to get clean CSV
        if (header && header.trim()) {
          // Find where the CSV actually starts by looking for the double newline after header
          const headerEndPattern = header.trim() + '\r\n\r\n';
          const headerEndIndex = csvData.indexOf(headerEndPattern);
          
          if (headerEndIndex >= 0) {
            // Extract CSV data after the header and double newlines
            csvData = csvData.substring(headerEndIndex + headerEndPattern.length);
            console.log('âœ… Successfully removed report header section');
            console.log('ğŸ“Š Clean CSV data length:', csvData.length);
          } else {
            // Try alternative patterns that might be in the data
            const patterns = [
              header.trim() + '\n\n',
              header.trim() + '\r\n', 
              header.trim()
            ];
            
            let found = false;
            for (const pattern of patterns) {
              const index = csvData.indexOf(pattern);
              if (index >= 0) {
                csvData = csvData.substring(index + pattern.length);
                // Skip any leading whitespace/newlines
                csvData = csvData.replace(/^[\s\r\n]+/, '');
                console.log(`âœ… Removed header using pattern: "${pattern.substring(0, 30)}..."`);
                console.log('ğŸ“Š Clean CSV data length:', csvData.length);
                found = true;
                break;
              }
            }
            
            if (!found) {
              console.log('âš ï¸ Could not find header pattern, using original CSV');
            }
          }
        }
        
        // Show first few lines for debugging
        const lines = csvData.split(/\r?\n/);
        console.log('ğŸ“„ Final CSV lines count:', lines.length);
        console.log('ğŸ“„ First 5 CSV lines:');
        for (let i = 0; i < Math.min(5, lines.length); i++) {
          console.log(`  Line ${i + 1}: "${lines[i]}"`);
        }
        
        // The tableToCsv function should have created proper CSV with headers
        // Trust that the table structure from rowHeaderEl and row1,row2... is correct
        
        // Create a File object from the pure CSV string for parseCSV function
        const csvBlob = new Blob([csvData], { type: 'text/csv' });
        const csvFile = new File([csvBlob], 'table_data.csv', { type: 'text/csv' });
        console.log('ğŸ“¦ Created File object:', csvFile.name, 'Size:', csvFile.size);
        
        // Update UI to show loading and report header
        $('#meta').textContent = 'Processing received table data...';
        
        // Display the report header if available
        if (header) {
          console.log('ğŸ“‹ Displaying report header');
          // Find or create a place to display the report title
          let reportTitleEl = document.getElementById('report-title');
          if (!reportTitleEl) {
            reportTitleEl = document.createElement('div');
            reportTitleEl.id = 'report-title';
            reportTitleEl.style.cssText = 'background: #f8fafc; padding: 12px; border-radius: 8px; margin: 16px 0px; border-left: 4px solid #2563eb; font-weight: 500;';
            // Insert after the section-content
            const mainSection = document.querySelector('.section');
            if (mainSection) {
              const sectionContent = mainSection.querySelector('.section-content');
              if (sectionContent) {
                sectionContent.insertAdjacentElement('afterend', reportTitleEl);
              }
            }
          }
          function formatHeaderForDisplay(rawHeader) {
            if (!rawHeader) return '';
            // Normalize newlines &nbsp; and tabs
            let s = rawHeader.replace(/\r\n/g,'\n').replace(/\r/g,'\n').replace(/\t/g,' ').replace(/\u00A0/g,' ');
            // Split and keep only lines that contain visible characters after trimming
            const lines = s.split('\n').map(l => l.replace(/\s+/g,' ').trim()).filter(l => l.length > 0);
            // Escape HTML (if header may contain user input) â€” keep simple escaping here
            const esc = str => String(str).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
            return lines.map(esc).join('<br>');
          }
          reportTitleEl.innerHTML = `<strong>Report:</strong> ` + formatHeaderForDisplay(header);
        }
        
        // Use the same logic as the Load CSV button
        const choice = $('#delimiter').value || 'auto';
        const hasHeader = $('#hasHeader').checked;
        console.log('âš™ï¸ Parse settings - Delimiter:', choice, 'Has header:', hasHeader);
        
        console.log('ğŸš€ Starting parseCSV...');
        const {data, meta} = await parseCSV(csvFile, choice, hasHeader);
        
        console.log('âœ… parseCSV completed');
        console.log('ğŸ“Š Parse results:');
        console.log('  - Data rows:', data ? data.length : 'null');
        console.log('  - Meta info:', meta);
        
        if (data && data.length > 0) {
          console.log('ğŸ“‹ First row structure:');
          console.log('  - Keys:', Object.keys(data[0]));
          console.log('  - Values:', Object.values(data[0]));
          console.log('ğŸ“‹ Sample of first 3 rows:');
          for (let i = 0; i < Math.min(3, data.length); i++) {
            console.log(`  Row ${i + 1}:`, data[i]);
          }
        }
        
        if (!data.length) throw new Error('No rows detected in received data.');
        
        // Set global variables same as loadBtn onclick
        console.log('ğŸ”§ Setting global variables...');
        ROWS = data; 
        DATA_COLUMNS = Object.keys(ROWS[0] || {});
        
        console.log('ğŸ“Š DATA_COLUMNS:', DATA_COLUMNS);
        
        PROFILE = profile(ROWS);
        console.log('ğŸ“Š PROFILE generated:', PROFILE);
        
        // Coerce numeric columns into numbers to avoid leftover leading-apostrophes in strings
        if (PROFILE && PROFILE.columns) {
          const numericCols = PROFILE.columns.filter(c => c.type === 'number').map(c => c.name);
          if (numericCols.length) {
            for (const r of ROWS) {
              for (const col of numericCols) {
                const cleaned = toNum(r[col]);
                // Only coerce when parsed is finite AND the original contains at least one digit
                if (Number.isFinite(cleaned) && /[0-9]/.test(String(r[col]))) {
                  r[col] = cleaned;
                }
              }
            }
          }
        }
        
        renderProfile(PROFILE);
        
        $('#meta').textContent = `Loaded ${PROFILE.rowCount.toLocaleString()} rows, ${PROFILE.columns.length} columns from table data. (delimiter="${meta.delimiter}")`;
        $('#results').innerHTML = '';
        
        // Initialize row inclusion with smart detection
        console.log('ğŸ”§ Initializing row inclusion...');
        initializeRowInclusion();
        
        // Build Raw Data table - this was missing!
        console.log('ğŸ”§ Building Raw Data table...');
        buildRawHeader(DATA_COLUMNS);
        
        // Reset search and pagination
        QUERY = ''; 
        $('#searchInput').value = '';
        SORT = { col: null, dir: 'asc' };
        RPP = Number($('#rowsPerPage').value) || 25; 
        PAGE = 1;
        
        // Apply filter and render the raw data table
        applyFilter(); 
        renderRawBody();
        console.log('âœ… Raw Data table rendered');
        
        // Reset manual overrides (same as loadBtn)
        MANUAL_ROLES = {}; 
        MANUAL_JOBS = [];
        $('#mode').value = 'auto';
        switchMode('auto');
        WorkflowManager.reset(MODE); // Clear AI todo list on new load
        
        // Enable other buttons
        $('#updateReportBtn').disabled = false;
        $('#saveAsNewBtn').disabled = false;
        
        // Auto-render aggregates if in auto mode
        if ($('#mode').value === 'auto') {
          console.log('ğŸ¯ Auto-rendering aggregates...');
          renderAggregates();
        }
        
        console.log('ğŸ‰ Successfully processed table data');
        showToast('Table data received and loaded successfully', 'success');
        
        // Auto-save the initial load as a new history item (same as loadBtn)
        try {
          console.log('ğŸ’¾ Auto-saving initial table data load...');
          await saveCurrentStateToHistory('Table Data Report', true); // true = force new entry
          console.log('âœ… Initial auto-save completed');
        } catch (saveError) {
          console.warn('âš ï¸ Auto-save failed:', saveError);
        }
      } catch (error) {
        console.error('âŒ Error processing received CSV data:', error);
        console.error('âŒ Error stack:', error.stack);
        $('#meta').textContent = 'Error processing received table data: ' + error.message;
        showToast('Failed to process table data: ' + error.message, 'error');
      }
    } else {
      console.warn('âš ï¸ No CSV data received in message');
    }
  }
});

// Send ready message to parent window
window.addEventListener('load', () => {
  if (window.opener && window.opener !== window) {
    try {
      window.opener.postMessage({ type: 'ready' }, window.location.origin);
    } catch (e) {
      console.log('Could not send ready message to parent:', e);
    }
  }
});

// AI Summary functionality
function checkAndGenerateAISummary() {
  const aiSummarySection = document.getElementById('ai-summary-section');
  const aiSummaryText = document.getElementById('ai-summary-text');
  const apiKey = localStorage.getItem('gemini_api_key');
  
  console.log('ğŸ¤– checkAndGenerateAISummary called');
  console.log('ğŸ¤– localStorage apiKey:', apiKey ? `"${apiKey.substring(0, 10)}..."` : 'null');
  console.log('ğŸ¤– aiSummarySection element:', aiSummarySection);
  
  // Only show AI Summary section if API key is present
  if (apiKey && apiKey.trim()) {
    console.log('ğŸ¤– API key detected, showing AI Summary section');
    if (aiSummarySection) {
      aiSummarySection.style.display = 'block';
      
      // Check if AI Summary already exists (from restored history)
      const existingSummary = aiSummaryText && aiSummaryText.innerHTML.trim();
      if (existingSummary && existingSummary.length > 0) {
        console.log('ğŸ“„ AI Summary already exists from history, skipping generation');
        return;
      }
      
      // Generate new summary only if none exists
      console.log('ğŸ†• No existing summary found, generating new one');
      generateAISummary();
    }
  } else {
    console.log('ğŸ¤– No API key, hiding AI Summary section');
    if (aiSummarySection) {
      aiSummarySection.style.display = 'none';
    }
  }
}

async function generateAISummary() {
  const loadingDiv = document.getElementById('ai-summary-loading');
  const textDiv = document.getElementById('ai-summary-text');
  const regenerateBtn = document.getElementById('regenerate-summary-btn');
  const apiKey = localStorage.getItem('gemini_api_key');
  
  try {
    // Show loading and disable button
    loadingDiv.style.display = 'block';
    textDiv.innerHTML = '';
    if (regenerateBtn) {
      regenerateBtn.disabled = true;
      regenerateBtn.textContent = 'ğŸ”„ Generating...';
    }
    
    console.log('ğŸ¤– Starting AI Summary generation...');
    
    // Collect all aggregate data and explanations
    const aggregateData = collectAggregateData();
    const summaryPrompt = createSummaryPrompt(aggregateData);

    // Use unified API wrapper with retry and language handling
    const model = localStorage.getItem('gemini_model') || 'gemini-2.5-flash';
    const language = localStorage.getItem('ai_language') || 'English';
    console.log('ğŸ¤– AI Summary settings:', { model, language });

    const summaryText = await fetchWithRetry(apiKey, model, summaryPrompt, (msg, type, timeoutMs) => {
      if (typeof showToast === 'function') {
        showToast(msg, type, timeoutMs);
      }
    });
    
    // Hide loading and show result
    loadingDiv.style.display = 'none';
    textDiv.innerHTML = marked.parse(summaryText || 'No summary generated');
    
    // Re-enable button
    if (regenerateBtn) {
      regenerateBtn.disabled = false;
      regenerateBtn.textContent = 'ğŸ”„ Regenerate';
    }
    
    console.log('ğŸ¤– AI Summary generated successfully');
    
    // Auto-save after AI Summary is generated
    console.log('ğŸ”„ Triggering auto-save after AI Summary generation...');
    debouncedAutoSave();
    
  } catch (error) {
    console.error('ğŸ¤– Error generating AI Summary:', error);
    loadingDiv.style.display = 'none';
    textDiv.innerHTML = `<div style="color: #d32f2f; padding: 12px; background-color: #ffebee; border-radius: 6px;">
      <strong>Error generating summary:</strong> ${error.message}
    </div>`;
    
    // Re-enable button on error
    if (regenerateBtn) {
      regenerateBtn.disabled = false;
      regenerateBtn.textContent = 'ğŸ”„ Regenerate';
    }
  }
}

function collectAggregateData() {
  const aggregateData = [];
  const cards = document.querySelectorAll('#results .card');
  
  console.log('ğŸ¤– Collecting data from', cards.length, 'aggregate cards');
  
  cards.forEach((card, index) => {
    const titleEl = card.querySelector('.card-title');
    const valueEl = card.querySelector('.card-sub');
    const explanationEl = card.querySelector('.ai-explanation-content');
    
    // Get chart information
    const chartType = card.querySelector('canvas') ? 'Chart' : 'Table';
    
    // Try to get explanation from multiple possible sources
    let explanation = 'No explanation available';
    if (explanationEl) {
      // Try to get stored markdown first, then fall back to text content
      explanation = card.dataset.explanationMarkdown || explanationEl.textContent.trim() || explanationEl.innerHTML;
    }
    
    if (titleEl && valueEl) {
      const data = {
        title: titleEl.textContent.trim(),
        value: valueEl.textContent.trim(),
        explanation: explanation,
        chartType: chartType,
        cardIndex: index + 1
      };
      
      console.log(`ğŸ¤– Card ${index + 1}:`, data.title, '=', data.value, '| Explanation length:', explanation.length);
      aggregateData.push(data);
    } else {
      console.log(`ğŸ¤– Card ${index + 1}: Missing title or value elements`);
    }
  });
  
  console.log('ğŸ¤– Collected', aggregateData.length, 'aggregate data items');
  return aggregateData;
}

function createSummaryPrompt(aggregateData) {
  let prompt = `You are a senior data analyst providing a final executive summary of a comprehensive data analysis.

Based on the following ${aggregateData.length} key metrics and their detailed AI explanations, provide a strategic executive summary that synthesizes the findings into actionable business insights.

## Data Analysis Results:
`;

  aggregateData.forEach((agg, index) => {
    prompt += `

### ${index + 1}. ${agg.title}
**Value:** ${agg.value}
**Visualization:** ${agg.chartType}
**Analysis:** ${agg.explanation}
`;
  });

  prompt += `

## Required Executive Summary Format:

Please provide a comprehensive summary in markdown format with these sections:

### ğŸ¯ Key Performance Highlights
- Top 3 most critical findings from the data

### ğŸ“Š Data Insights & Patterns  
- Major trends and patterns identified
- Notable correlations or anomalies

### ğŸ’¡ Business Implications
- What these findings mean for the business
- Areas of strength and concern

### ğŸš€ Strategic Recommendations
- 3-5 specific, actionable recommendations based on the analysis
- Priority level for each recommendation

Focus on strategic insights rather than restating the individual explanations. Synthesize the information to tell the complete story of what the data reveals about business performance.`;

  return prompt;
}

// Also check for AI Summary when API key changes in localStorage
// Listen for storage changes (when API key is saved in the settings modal)
window.addEventListener('storage', (e) => {
  if (e.key === 'gemini_api_key') {
    // Only check if we have aggregates to summarize
    const cards = document.querySelectorAll('.aggregate-card');
    if (cards.length > 0) {
      console.log('ğŸ¤– API key changed in localStorage, checking AI Summary');
      checkAndGenerateAISummary();
    }
  }
});

// Also add a custom event listener for when API key is saved in the same window
document.addEventListener('apiKeySaved', () => {
  const cards = document.querySelectorAll('.aggregate-card');
  if (cards.length > 0) {
    console.log('ğŸ¤– API key saved event received, checking AI Summary');
    checkAndGenerateAISummary();
  }
});

// Add regenerate button functionality
document.addEventListener('DOMContentLoaded', () => {
  const regenerateBtn = document.getElementById('regenerate-summary-btn');
  if (regenerateBtn) {
    regenerateBtn.addEventListener('click', () => {
      const apiKey = localStorage.getItem('gemini_api_key');
      if (apiKey && apiKey.trim()) {
        console.log('ğŸ¤– Regenerate button clicked, generating new summary');
        generateAISummary();
      } else {
        console.log('ğŸ¤– No API key available for regeneration');
        alert('Please set your API key in the AI settings first.');
      }
    });
  }

  // ========= AI Analysis Chat Implementation =========
  
  // Chat state management
  const chatState = {
    messages: [],
    isTyping: false,
    lastContextRefresh: null
  };

  // Context gathering system
  function gatherAnalysisContext() {
    const context = {
      timestamp: Date.now(),
      dataset: null,
      charts: [],
      summary: null
    };

    // Gather dataset information
    if (window.currentData && window.currentData.length > 0) {
      const sampleSize = Math.min(5, window.currentData.length);
      context.dataset = {
        rowCount: window.currentData.length,
        columns: Object.keys(window.currentData[0] || {}),
        sampleData: window.currentData.slice(0, sampleSize)
      };
    }

    // Gather chart configurations and data
    const chartCards = document.querySelectorAll('.card');
    console.log('ğŸ” Context gathering debug:', {
      cardElements: chartCards.length,
      totalElements: document.querySelectorAll('*').length
    });
    
    chartCards.forEach((card, index) => {
      const titleElement = card.querySelector('h4');
      const title = titleElement ? titleElement.textContent : `Chart ${index + 1}`;
      
      const chartElements = card.querySelectorAll('.chart-card');
      console.log(`ğŸ” Card ${index}: title="${title}", chartElements=${chartElements.length}`);
      
      const charts = [];
      
      chartElements.forEach((chartCard, chartIndex) => {
        const canvas = chartCard.querySelector('canvas');
        const chartTypeSelect = chartCard.querySelector('.chart-type-select');
        const topNSelect = chartCard.querySelector('.chart-topn-select');
        
        console.log(`ğŸ” Chart ${chartIndex}: canvas=${!!canvas}, hasChart=${!!(canvas && canvas.chart)}`);
        
        if (canvas) {
          // Try multiple ways to detect chart data
          const chartInstance = canvas.chart || canvas._chartInstance;
          const hasChartData = !!(chartInstance || canvas.dataset.chartType);
          
          if (chartInstance) {
            charts.push({
              type: chartTypeSelect ? chartTypeSelect.value : 'unknown',
              topN: topNSelect ? topNSelect.value : null,
              data: chartInstance.data,
              options: chartInstance.options
            });
          } else if (hasChartData) {
            // Fallback: basic chart info without full Chart.js data
            charts.push({
              type: chartTypeSelect ? chartTypeSelect.value : 'unknown',
              topN: topNSelect ? topNSelect.value : null,
              title: title,
              hasCanvas: true
            });
          }
        }
      });

      console.log(`ğŸ” Card ${index} final: ${charts.length} charts added`);
      
      // Always add the card to context, gathering available data from DOM
      if (chartElements.length > 0) {
        // Gather rich context from DOM elements
        const tableData = [];
        const table = card.querySelector('table');
        if (table) {
          const rows = table.querySelectorAll('tbody tr');
          const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
          
          Array.from(rows).slice(0, 5).forEach(row => { // Get first 5 rows
            const cells = Array.from(row.querySelectorAll('td')).map(td => td.textContent.trim());
            if (cells.length > 0) {
              tableData.push(cells);
            }
          });
        }

        // Get chart type selector values
        const chartTypeSelects = card.querySelectorAll('.chart-type-select');
        const chartTypes = Array.from(chartTypeSelects).map(select => select.value);
        
        // Get card subtitle for additional context
        const subtitle = card.querySelector('.card-sub');
        const subtitleText = subtitle ? subtitle.textContent.trim() : '';

        // Reconstruct aggregation data using stored job parameters
        let aggregationData = null;
        try {
          if (card.dataset.groupBy && card.dataset.metric && card.dataset.agg && window.currentData) {
            const filterValue = Number(card.querySelector('.filter-input')?.value || 0);
            const filterMode = card.querySelector('.filter-mode-select')?.value || 'share';
            const showMissing = card.dataset.showMissing === 'true';
            
            // Use the same groupAgg function that builds the charts
            if (typeof groupAgg === 'function' && typeof getIncludedRows === 'function') {
              aggregationData = groupAgg(
                getIncludedRows(), 
                card.dataset.groupBy, 
                card.dataset.metric, 
                card.dataset.agg, 
                card.dataset.dateBucket || '', 
                { mode: filterMode, value: filterValue }, 
                showMissing
              );
            }
          }
        } catch (error) {
          console.warn('Could not reconstruct aggregation data:', error);
        }

        // Get AI explanation if stored (check both dataset and rendered content)
        const explanationEl = card.querySelector('.ai-explanation-content');
        const explanation = card.dataset.explanationMarkdown || (explanationEl ? explanationEl.innerHTML : '') || '';
        
        console.log(`ğŸ” Explanation check for card "${title}":`, {
          hasDatasetMarkdown: !!card.dataset.explanationMarkdown,
          hasContentElement: !!explanationEl,
          contentLength: explanationEl ? explanationEl.innerHTML.length : 0,
          finalExplanation: !!explanation && explanation.trim().length > 0
        });

        const chartContext = {
          title: title,
          subtitle: subtitleText,
          chartTypes: chartTypes.length > 0 ? chartTypes : ['unknown'],
          tableHeaders: table ? Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim()) : [],
          sampleData: tableData,
          chartCount: chartElements.length,
          hasData: tableData.length > 0,
          // Rich aggregation data
          aggregation: (aggregationData && aggregationData.rows) ? {
            groupBy: card.dataset.groupBy,
            metric: card.dataset.metric,
            aggregation: card.dataset.agg,
            dateBucket: card.dataset.dateBucket,
            rowCount: aggregationData.rows.length,
            sampleRows: aggregationData.rows.slice(0, 5),
            headers: aggregationData.header
          } : null,
          aiExplanation: explanation
        };
        
        console.log(`ğŸ” Rich context for card ${index}:`, {
          title: chartContext.title,
          subtitle: chartContext.subtitle,
          chartTypes: chartContext.chartTypes,
          headerCount: chartContext.tableHeaders.length,
          dataRows: chartContext.sampleData.length,
          hasTable: !!table,
          hasAggregation: !!chartContext.aggregation,
          aggregationRows: chartContext.aggregation ? chartContext.aggregation.rowCount : 0,
          hasAIExplanation: !!chartContext.aiExplanation,
          jobParams: {
            groupBy: card.dataset.groupBy,
            metric: card.dataset.metric,
            agg: card.dataset.agg
          }
        });
        
        context.charts.push(chartContext);
      }
    });
    
    console.log('ğŸ” Final context:', {
      datasetExists: !!context.dataset,
      totalCharts: context.charts.length,
      chartTitles: context.charts.map(c => c.title)
    });

    // Gather AI summary if available
    const summaryElement = document.getElementById('ai-summary-text');
    if (summaryElement && summaryElement.textContent.trim()) {
      context.summary = summaryElement.textContent.trim();
    }

    return context;
  }

  // Update context status UI
  function updateContextStatus(context) {
    const contextText = document.getElementById('context-text');
    const chartsCount = document.getElementById('charts-count');
    const lastUpdated = document.getElementById('context-last-updated');
    
    if (contextText) {
      const status = context.dataset ? 'Ready' : 'No data loaded';
      contextText.textContent = `Context: ${status}`;
    }
    
    if (chartsCount) {
      const chartsArray = context.charts || [];
      chartsCount.textContent = `Charts: ${chartsArray.length}`;
    }
    
    if (lastUpdated) {
      lastUpdated.textContent = `Last updated: ${new Date(context.timestamp).toLocaleTimeString()}`;
    }

    // Update detailed breakdown sections
    updateChartBreakdown(context.charts || []);
    updateExplanationBreakdown(context.charts || []);
    updateSummaryBreakdown(context.summary || null);
    updateDatasetBreakdown(context.dataset || null);
    
    chatState.lastContextRefresh = context.timestamp;
  }

  // Update chart data breakdown
  function updateChartBreakdown(charts) {
    const breakdown = document.getElementById('chart-breakdown-list');
    if (!breakdown) return;

    if (!charts || charts.length === 0) {
      breakdown.innerHTML = '<div class="context-item-empty">No charts available</div>';
      return;
    }

    const chartItems = charts.map((chart, index) => {
      const hasData = chart.aggregation && chart.aggregation.rowCount > 0;
      const dataStatus = hasData 
        ? `âœ… ${chart.aggregation.rowCount} data rows`
        : chart.hasData 
        ? `âš ï¸ Table data only`
        : `âŒ No data`;
        
      return `
        <div class="context-item">
          <div class="context-item-title">${chart.title}</div>
          <div class="context-item-details">
            <span class="context-badge">${chart.chartTypes.join(', ')}</span>
            <span class="context-status">${dataStatus}</span>
          </div>
          ${hasData ? `<div class="context-item-meta">${chart.aggregation.groupBy} â†’ ${chart.aggregation.metric}</div>` : ''}
        </div>
      `;
    }).join('');

    breakdown.innerHTML = chartItems;
  }

  // Update AI explanations breakdown
  function updateExplanationBreakdown(charts) {
    const breakdown = document.getElementById('explanation-breakdown');
    if (!breakdown) return;

    if (!charts) {
      breakdown.innerHTML = '<div class="context-item-empty">No AI explanations available</div>';
      return;
    }

    const explanations = charts.filter(chart => chart.aiExplanation && chart.aiExplanation.trim());
    
    if (explanations.length === 0) {
      breakdown.innerHTML = '<div class="context-item-empty">No AI explanations available</div>';
      return;
    }

    const explanationItems = explanations.map((chart, index) => {
      const wordCount = chart.aiExplanation.split(/\s+/).length;
      return `
        <div class="context-item">
          <div class="context-item-title">${chart.title}</div>
          <div class="context-item-details">
            <span class="context-status">âœ… ${wordCount} words</span>
          </div>
        </div>
      `;
    }).join('');

    breakdown.innerHTML = `
      <div class="context-summary-stat">
        <strong>${explanations.length}</strong> of <strong>${charts.length}</strong> charts have explanations
      </div>
      ${explanationItems}
    `;
  }

  // Update AI summary breakdown  
  function updateSummaryBreakdown(summary) {
    const breakdown = document.getElementById('summary-breakdown');
    if (!breakdown) return;

    if (!summary || !summary.trim()) {
      breakdown.innerHTML = '<div class="context-item-empty">No AI summary available</div>';
      return;
    }

    const wordCount = summary.split(/\s+/).length;
    breakdown.innerHTML = `
      <div class="context-item">
        <div class="context-item-title">Final Analysis Summary</div>
        <div class="context-item-details">
          <span class="context-status">âœ… ${wordCount} words</span>
        </div>
      </div>
    `;
  }

  // Update dataset breakdown
  function updateDatasetBreakdown(dataset) {
    const breakdown = document.getElementById('dataset-breakdown');
    if (!breakdown) return;

    if (!dataset) {
      breakdown.innerHTML = '<div class="context-item-empty">No dataset loaded</div>';
      return;
    }

    breakdown.innerHTML = `
      <div class="context-item">
        <div class="context-item-title">Dataset Overview</div>
        <div class="context-item-details">
          <span class="context-badge">${dataset.rowCount || 0} rows</span>
          <span class="context-badge">${(dataset.columns || []).length} columns</span>
        </div>
        <div class="context-item-meta">Columns: ${(dataset.columns || []).join(', ')}</div>
      </div>
    `;
  }

  // Add message to chat
  function addChatMessage(content, isUser = false) {
    const message = {
      id: Date.now(),
      content: content,
      isUser: isUser,
      timestamp: new Date()
    };
    
    chatState.messages.push(message);
    renderChatMessage(message);
    
    // Scroll to bottom
    const messagesContainer = document.getElementById('chat-messages');
    if (messagesContainer) {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    return message;
  }

  // Render a chat message
  function renderChatMessage(message) {
    const messagesContainer = document.getElementById('chat-messages');
    if (!messagesContainer) return;

    const messageDiv = document.createElement('div');
    messageDiv.className = message.isUser ? 'user-message' : 'ai-message';
    
    // Process content based on message type
    let processedContent;
    if (message.isUser) {
      // User messages: simple text, escape HTML
      processedContent = `<p>${message.content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`;
    } else {
      // AI messages: render as Markdown
      try {
        if (typeof marked !== 'undefined' && typeof marked.parse === 'function') {
          processedContent = marked.parse(message.content);
        } else {
          // Fallback: basic formatting if marked.js isn't available
          processedContent = message.content
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/`(.*?)`/g, '<code>$1</code>')
            .replace(/\n\n/g, '</p><p>')
            .replace(/\n/g, '<br>');
          processedContent = `<p>${processedContent}</p>`;
        }
      } catch (error) {
        console.warn('Markdown rendering failed:', error);
        processedContent = `<p>${message.content}</p>`;
      }
    }
    
    messageDiv.innerHTML = `
      <div class="message-avatar">${message.isUser ? 'ğŸ‘¤' : 'ğŸ¤–'}</div>
      <div class="message-content">
        ${processedContent}
      </div>
    `;

    messagesContainer.appendChild(messageDiv);
  }

  // Show typing indicator
  function showTypingIndicator() {
    const typingIndicator = document.getElementById('chat-typing-indicator');
    if (typingIndicator) {
      typingIndicator.style.display = 'flex';
    }
    chatState.isTyping = true;
  }

  // Hide typing indicator
  function hideTypingIndicator() {
    const typingIndicator = document.getElementById('chat-typing-indicator');
    if (typingIndicator) {
      typingIndicator.style.display = 'none';
    }
    chatState.isTyping = false;
  }

  // Send chat message to AI
  async function sendChatMessage(userMessage) {
    try {
      // Gather fresh context
      const context = gatherAnalysisContext();
      updateContextStatus(context);

      // Add user message to chat
      addChatMessage(userMessage, true);
      
      // Show typing indicator
      showTypingIndicator();

      // Prepare context for AI
      const contextPrompt = `
System: You are a helpful data analysis assistant. Provide insights about charts, data patterns, and analytics. Be conversational and helpful.

=== DATASET OVERVIEW ===
${context.dataset ? `
- Total Records: ${context.dataset.rowCount}
- Columns (${context.dataset.columns.length}): ${context.dataset.columns.join(', ')}
- Sample Data Preview:
${context.dataset.sampleData ? context.dataset.sampleData.slice(0, 3).map(row => '  ' + Object.entries(row).map(([k,v]) => `${k}: ${v}`).join(', ')).join('\n') : 'No sample data available'}
` : 'No dataset loaded'}

=== CHART ANALYSIS (${(context.charts || []).length} charts) ===
${(context.charts || []).map(chart => {
  let chartInfo = `\nğŸ“Š ${chart.title}`;
  if (chart.subtitle) chartInfo += `\n   Subtitle: ${chart.subtitle}`;
  chartInfo += `\n   Type: ${(chart.chartTypes || []).join(', ')}`;
  
  // Add aggregation details if available
  if (chart.aggregation) {
    chartInfo += `\n   Analysis: ${chart.aggregation.aggregation}(${chart.aggregation.metric}) grouped by ${chart.aggregation.groupBy}`;
    chartInfo += `\n   Data Points: ${chart.aggregation.rowCount} rows`;
    
    // Include sample aggregated data
    if (chart.aggregation.sampleRows && chart.aggregation.headers) {
      chartInfo += `\n   Top Results:`;
      chart.aggregation.sampleRows.slice(0, 5).forEach(row => {
        chartInfo += `\n     â€¢ ${row[0]}: ${row[1]}`;
      });
    }
  }
  
  // Add table data if available
  if (chart.sampleData && chart.sampleData.length > 0) {
    chartInfo += `\n   Table Data (${chart.sampleData.length} rows shown):`;
    if (chart.tableHeaders && chart.tableHeaders.length > 0) {
      chartInfo += `\n     Headers: ${chart.tableHeaders.join(' | ')}`;
      chart.sampleData.slice(0, 3).forEach(row => {
        chartInfo += `\n     ${row.join(' | ')}`;
      });
    }
  }
  
  // Add AI explanation if available
  if (chart.aiExplanation && chart.aiExplanation.trim()) {
    const cleanExplanation = chart.aiExplanation.replace(/<[^>]*>/g, '').trim();
    if (cleanExplanation) {
      chartInfo += `\n   AI Insight: ${cleanExplanation.substring(0, 200)}${cleanExplanation.length > 200 ? '...' : ''}`;
    }
  }
  
  return chartInfo;
}).join('\n')}

${context.summary ? `
=== AI SUMMARY ===
${context.summary.substring(0, 500)}${context.summary.length > 500 ? '...' : ''}
` : ''}

=== USER QUESTION ===
${userMessage}

Please provide a helpful, insightful response based on the above data analysis context. Use specific numbers and insights from the charts when possible.`;

      // Get API key from settings (using same pattern as existing AI features)
      const apiKey = localStorage.getItem('gemini_api_key');
      const model = localStorage.getItem('gemini_model') || 'gemini-2.0-flash-exp';
      const baseUrl = localStorage.getItem('gemini_base_url') || 'https://generativelanguage.googleapis.com/v1beta';
      
      console.log('ğŸ” Chat API Settings:', {
        hasApiKey: !!apiKey,
        model: model,
        baseUrl: baseUrl,
        apiKeyLength: apiKey ? apiKey.length : 0
      });
      
      if (!apiKey || apiKey.trim() === '') {
        console.log('âŒ No API key found in settings');
        hideTypingIndicator();
        addChatMessage("Please set your API key in AI Settings first.", false);
        return;
      }

      console.log('ğŸŒ Making API call:', {
        model: model,
        apiKeyLength: apiKey.length,
        contextLength: contextPrompt.length
      });

      // Call Gemini API using the same pattern as existing AI features
      const prompt = `System: You are a helpful data analysis assistant. Provide insights about charts, data patterns, and analytics. Be conversational and helpful.\n\nUser: ${contextPrompt}`;
      
      const response = await fetchWithRetry(apiKey, model, prompt, (msg, type) => {
        if (typeof showToast === 'function') {
          showToast(msg, type);
        }
      });

      console.log('âœ… API Response received:', {
        responseType: typeof response,
        responseLength: response ? response.length : 0,
        firstChars: response ? response.substring(0, 100) : 'No response'
      });
      
      const aiResponse = response || 'Sorry, I could not generate a response.';
      
      hideTypingIndicator();
      addChatMessage(aiResponse, false);

    } catch (error) {
      console.error('Chat error:', error);
      hideTypingIndicator();
      addChatMessage(`Error: ${error.message}`, false);
    }
  }

  // Initialize chat functionality
  window.initializeChat = function initializeChat() {
    const chatSection = document.getElementById('ai-analysis-section');
    const sendBtn = document.getElementById('send-chat-btn');
    const chatInput = document.getElementById('chat-input');
    const refreshContextBtn = document.getElementById('refresh-context-btn');
    const clearChatBtn = document.getElementById('clear-chat-btn');
    const toggleContextBtn = document.getElementById('toggle-context-details');

    if (!chatSection || !sendBtn || !chatInput) return;
    
    // Prevent duplicate initialization
    if (chatSection.hasAttribute('data-chat-initialized')) return;
    chatSection.setAttribute('data-chat-initialized', 'true');

    // Show chat section when data is loaded
    if (window.currentData && window.currentData.length > 0) {
      chatSection.style.display = 'block';
      console.log('ğŸ“± AI Analysis Chat section shown');
    } else {
      console.log('ğŸ“± AI Analysis Chat section hidden - no data loaded');
    }

    // Send message on button click
    sendBtn.addEventListener('click', () => {
      const message = chatInput.value.trim();
      if (message && !chatState.isTyping) {
        chatInput.value = '';
        sendBtn.disabled = true;
        sendChatMessage(message);
      }
    });

    // Send message on Enter (Shift+Enter for new line)
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendBtn.click();
      }
    });

    // Enable/disable send button based on input
    chatInput.addEventListener('input', () => {
      sendBtn.disabled = !chatInput.value.trim() || chatState.isTyping;
    });

    // Refresh context button
    if (refreshContextBtn) {
      refreshContextBtn.addEventListener('click', () => {
        const context = gatherAnalysisContext();
        updateContextStatus(context);
        if (typeof showToast === 'function') {
          showToast('Context refreshed successfully!');
        }
      });
    }

    // Clear chat button
    if (clearChatBtn) {
      clearChatBtn.addEventListener('click', () => {
        chatState.messages = [];
        const messagesContainer = document.getElementById('chat-messages');
        if (messagesContainer) {
          messagesContainer.innerHTML = `
            <div class="welcome-message">
              <div class="ai-message">
                <div class="message-avatar">ğŸ¤–</div>
                <div class="message-content">
                  <p>Hello! I'm your AI assistant for data analysis. I have access to your current charts, aggregations, and data patterns. Ask me anything about your data!</p>
                </div>
              </div>
            </div>
          `;
        }
        if (typeof showToast === 'function') {
          showToast('Chat history cleared!');
        }
      });
    }

    // Toggle context details
    if (toggleContextBtn) {
      toggleContextBtn.addEventListener('click', () => {
        const contextDetails = document.getElementById('context-details');
        if (contextDetails) {
          const isHidden = contextDetails.style.display === 'none';
          contextDetails.style.display = isHidden ? 'block' : 'none';
          toggleContextBtn.textContent = isHidden ? 'â–²' : 'â–¼';
        }
      });
    }

    // Initialize context
    const context = gatherAnalysisContext();
    updateContextStatus(context);
  }

  // Hook into existing data loading to show chat
  const originalRenderAggregates = window.renderAggregates;
  if (originalRenderAggregates) {
    window.renderAggregates = async function(...args) {
      const result = await originalRenderAggregates.apply(this, args);
      
      // Show chat section after charts are rendered
      setTimeout(() => {
        const chatSection = document.getElementById('ai-analysis-section');
        if (chatSection && window.currentData && window.currentData.length > 0) {
          chatSection.style.display = 'block';
          window.initializeChat();
        }
      }, 500);
      
      return result;
    };
  }

  // Initialize chat on page load if data exists
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      if (window.currentData && window.currentData.length > 0) {
        window.initializeChat();
      }
    }, 1000);
  });

});

</script>
</main>
<div id="floating-tooltip" aria-hidden="true"></div>
<script>
 document.addEventListener('DOMContentLoaded', () => {
   const chatInput = document.getElementById('chat-input');
   if (chatInput) {
     const initialHeight = getComputedStyle(chatInput).height;
     const expandedHeight = '120px'; // Define a larger height for focus
 
     // Function to expand based on content, but not less than the expanded height
     const autoExpand = () => {
       chatInput.style.height = 'auto'; // Reset to calculate scrollHeight correctly
       const scrollHeight = chatInput.scrollHeight;
       // Use the larger of the scroll height or the defined expanded height
       chatInput.style.height = Math.max(scrollHeight, parseInt(expandedHeight)) + 'px';
     };
 
     // On focus, expand to the defined larger height
     chatInput.addEventListener('focus', () => {
       chatInput.style.height = expandedHeight;
       // Also run autoExpand in case there's already content
       autoExpand();
     });
 
     // On input, continue to expand with content
     chatInput.addEventListener('input', autoExpand);
 
     // On blur, reset to initial height only if empty
     chatInput.addEventListener('blur', () => {
       if (chatInput.value.trim() === '') {
         chatInput.style.height = initialHeight;
       }
     });
   }
   const tooltip = document.getElementById('floating-tooltip');
   if (!tooltip) return;

   const sidebar = document.getElementById('sidebar');
   const historyList = document.getElementById('history-list');

   if (!sidebar || !historyList) return;

   const showTooltip = (e) => {
     if (!sidebar.classList.contains('collapsed')) return;
     const target = e.target.closest('.history-item');
     if (!target) return;

     const tooltipText = target.getAttribute('data-tooltip');
     if (!tooltipText) return;

     tooltip.textContent = tooltipText;
     tooltip.classList.add('show');

     const targetRect = target.getBoundingClientRect();
     const tooltipRect = tooltip.getBoundingClientRect();

     tooltip.style.left = `${targetRect.right + 12}px`;
     tooltip.style.top = `${targetRect.top + (targetRect.height / 2)}px`;
   };

   const hideTooltip = () => {
     tooltip.classList.remove('show');
   };

   historyList.addEventListener('mouseover', showTooltip);
   historyList.addEventListener('mouseout', hideTooltip);
   historyList.addEventListener('focusin', showTooltip);
   historyList.addEventListener('focusout', hideTooltip);
 });
</script>
</body>
</html>
